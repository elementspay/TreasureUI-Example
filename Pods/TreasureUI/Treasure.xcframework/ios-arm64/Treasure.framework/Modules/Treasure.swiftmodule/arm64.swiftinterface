// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5 (swiftlang-1300.0.31.1 clang-1300.0.29.1)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Treasure
import CoreGraphics
import Darwin/*.fputs*/
import Foundation
import ObjectiveC
import Swift
@_exported import Treasure
import UIKit
import _Concurrency
public enum SwipeButtonDisplayMode {
  case titleAndImage, titleOnly, imageOnly
  public static func == (a: Treasure.SwipeButtonDisplayMode, b: Treasure.SwipeButtonDisplayMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SwipeButtonStyle {
  case backgroundColor, circular
  public static func == (a: Treasure.SwipeButtonStyle, b: Treasure.SwipeButtonStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SwipeActionDescriptor {
  case read, unread, more, rewrite, trash
  public func title(forDisplayMode displayMode: Treasure.SwipeButtonDisplayMode) -> Swift.String?
  public func image(forStyle style: Treasure.SwipeButtonStyle, displayMode: Treasure.SwipeButtonDisplayMode) -> UIKit.UIImage?
  public func color(forStyle _: Treasure.SwipeButtonStyle) -> UIKit.UIColor
  public func circularIcon(with color: UIKit.UIColor, size: CoreGraphics.CGSize, icon: UIKit.UIImage? = nil) -> UIKit.UIImage?
  public static func == (a: Treasure.SwipeActionDescriptor, b: Treasure.SwipeActionDescriptor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol HighlightableView : UIKit.UIView {
  func didHighlight(_ highlighted: Swift.Bool)
}
public protocol NVActivityIndicatorViewable {
}
extension Treasure.NVActivityIndicatorViewable where Self : UIKit.UIViewController {
  public var isAnimating: Swift.Bool {
    get
  }
  public func startAnimating(_ size: CoreGraphics.CGSize? = nil, message: Swift.String? = nil, messageFont: UIKit.UIFont? = nil, type: Treasure.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreGraphics.CGFloat? = nil, displayTimeThreshold: Swift.Int? = nil, minimumDisplayTime: Swift.Int? = nil, backgroundColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil, fadeInAnimation: Treasure.FadeInAnimation? = NVActivityIndicatorView.DEFAULT_FADE_IN_ANIMATION)
  public func stopAnimating(_ fadeOutAnimation: Treasure.FadeOutAnimation? = NVActivityIndicatorView.DEFAULT_FADE_OUT_ANIMATION)
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView {
  public static func barModel(dataID: Swift.AnyHashable? = nil, content: Self.Content, behaviors: Self.Behaviors? = nil, style: Self.Style) -> Treasure.BarModel<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Style == Swift.Never {
  public static func barModel(dataID: Swift.AnyHashable? = nil, content: Self.Content, behaviors: Self.Behaviors? = nil) -> Treasure.BarModel<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Content == Swift.Never {
  public static func barModel(dataID: Swift.AnyHashable? = nil, behaviors: Self.Behaviors? = nil, style: Self.Style) -> Treasure.BarModel<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Content == Swift.Never, Self.Style == Swift.Never {
  public static func barModel(dataID: Swift.AnyHashable? = nil, behaviors: Self.Behaviors? = nil) -> Treasure.BarModel<Self>
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CollectionViewReusableView : UIKit.UICollectionReusableView {
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) final public var view: UIKit.UIView? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public func setViewIfNeeded(view: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) @objc override final public func preferredLayoutAttributesFitting(_ layoutAttributes: UIKit.UICollectionViewLayoutAttributes) -> UIKit.UICollectionViewLayoutAttributes
  @objc deinit
}
public struct ExternalAction : Treasure.TreasureAction {
  public let analytics: Treasure.TreasureAnalytics?
  public let actionType: Swift.String
  public let data: Treasure.DynamicObject?
  public init(actionType: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func executeAction(params: Treasure.TreasureActionParameters)
}
extension Treasure.HGroup {
  public enum ItemAlignment : Swift.Hashable, Swift.Equatable {
    case fill
    case top
    case bottom
    case center
    case centered(to: Treasure.Constrainable)
    case custom(alignmentID: Swift.AnyHashable, layoutProvider: (_ container: Treasure.Constrainable, _ constrainable: Treasure.Constrainable) -> [UIKit.NSLayoutConstraint])
    public static func == (lhs: Treasure.HGroup.ItemAlignment, rhs: Treasure.HGroup.ItemAlignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public typealias EpoxyableView = Treasure.BehaviorsConfigurableView & Treasure.ContentConfigurableView & Treasure.StyledView
extension Treasure.FileWatcher {
  final public class Local : Treasure.FileWatcherProtocol {
    public init(path: Swift.String, refreshInterval: Foundation.TimeInterval = 1/60, queue: Dispatch.DispatchQueue = DispatchQueue.main)
    final public func start(closure: @escaping Treasure.FileWatcher.UpdateClosure) throws
    final public func stop() throws
    @objc deinit
    final public func refresh()
  }
}
extension Treasure.DynamicObject : Swift.ExpressibleByNilLiteral, Swift.ExpressibleByBooleanLiteral, Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByStringLiteral, Swift.ExpressibleByStringInterpolation, Swift.ExpressibleByArrayLiteral, Swift.ExpressibleByDictionaryLiteral {
  public init(nilLiteral: Swift.Void)
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Treasure.DynamicObject...)
  public init(dictionaryLiteral elements: (Swift.String, Treasure.DynamicObject)...)
  public typealias ArrayLiteralElement = Treasure.DynamicObject
  public typealias BooleanLiteralType = Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
  public typealias Key = Swift.String
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public typealias Value = Treasure.DynamicObject
}
public protocol ItemsProviding {
  var items: [Treasure.ItemModeling] { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.ItemsProviding {
  public var items: [Treasure.ItemModeling] {
    get
    set
  }
  public func items(_ value: [Treasure.ItemModeling]) -> Self
}
@_functionBuilder public struct EpoxyModelArrayBuilder<Model> {
  public typealias Expression = Model
  public typealias Component = [Model]
  public static func buildExpression(_ expression: Treasure.EpoxyModelArrayBuilder<Model>.Expression) -> Treasure.EpoxyModelArrayBuilder<Model>.Component
  public static func buildExpression(_ expression: Treasure.EpoxyModelArrayBuilder<Model>.Component) -> Treasure.EpoxyModelArrayBuilder<Model>.Component
  public static func buildExpression(_ expression: Treasure.EpoxyModelArrayBuilder<Model>.Expression?) -> Treasure.EpoxyModelArrayBuilder<Model>.Component
  public static func buildBlock(_ children: Treasure.EpoxyModelArrayBuilder<Model>.Component...) -> Treasure.EpoxyModelArrayBuilder<Model>.Component
  public static func buildBlock(_ component: Treasure.EpoxyModelArrayBuilder<Model>.Component) -> Treasure.EpoxyModelArrayBuilder<Model>.Component
  public static func buildOptional(_ children: Treasure.EpoxyModelArrayBuilder<Model>.Component?) -> Treasure.EpoxyModelArrayBuilder<Model>.Component
  public static func buildEither(first child: Treasure.EpoxyModelArrayBuilder<Model>.Component) -> Treasure.EpoxyModelArrayBuilder<Model>.Component
  public static func buildEither(second child: Treasure.EpoxyModelArrayBuilder<Model>.Component) -> Treasure.EpoxyModelArrayBuilder<Model>.Component
  public static func buildArray(_ components: [Treasure.EpoxyModelArrayBuilder<Model>.Component]) -> Treasure.EpoxyModelArrayBuilder<Model>.Component
}
public enum ImageContentMode : Swift.String, Swift.Decodable {
  case scaleAspectFit
  case scaleToFill
  case scaleAspectFill
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct ImageElementStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public let imageCornerRadius: Swift.Double?
  public let imageHeight: Swift.Double?
  public let imageWidth: Swift.Double?
  public let imageMode: Treasure.ImageContentMode?
  public init(id: Swift.String, basicProps: Treasure.ElementStyleProps? = nil, imageCornerRadius: Swift.Double? = nil, imageHeight: Swift.Double? = nil, imageWidth: Swift.Double? = nil, imageMode: Treasure.ImageContentMode? = nil)
  public init(from decoder: Swift.Decoder) throws
}
public struct ImageElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let style: Treasure.Expression<Swift.String>?
  public let accessibilityLabel: Swift.String?
  public let image: Treasure.Expression<Treasure.TreasureImageSource>
  public let onPressAction: Treasure.Expression<Treasure.AnyTreasureAction>?
  public init(id: Swift.String, style: Treasure.Expression<Swift.String>? = nil, accessibilityLabel: Swift.String? = nil, image: Treasure.Expression<Treasure.TreasureImageSource>, onPressAction: Treasure.Expression<Treasure.AnyTreasureAction>? = nil)
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
extension UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) public func setBackgroundColor(color: UIKit.UIColor, forState: UIKit.UIControl.State)
}
@_hasMissingDesignatedInitializers open class Presenter<ViewControllerType> {
  @objc deinit
}
public protocol CollectionViewAccessibilityDelegate : AnyObject {
  func collectionView(_ collectionView: Treasure.CollectionView, itemDidBecomeFocused item: Treasure.AnyItemModel, with view: UIKit.UIView?, in section: Treasure.SectionModel)
  func collectionView(_ collectionView: Treasure.CollectionView, itemDidLoseFocus item: Treasure.AnyItemModel, with view: UIKit.UIView?, in section: Treasure.SectionModel)
}
@objc @_Concurrency.MainActor(unsafe) public class InteractivePopRecognizer : ObjectiveC.NSObject, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) public var navigationController: UIKit.UINavigationController
  @_Concurrency.MainActor(unsafe) public init(controller: UIKit.UINavigationController)
  @_Concurrency.MainActor(unsafe) @objc public func gestureRecognizerShouldBegin(_: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc public func gestureRecognizer(_: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith _: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc deinit
}
public struct TreasureView : Swift.Decodable {
  public let context: Treasure.Context?
  public let screens: [Treasure.TreasureScreen]
  public let sections: [Treasure.TreasureSection]
  public let blueprints: [Treasure.TreasureElement]
  public let styles: [Treasure.ElementStyle]
  public init(from decoder: Swift.Decoder) throws
}
public protocol SelectableView : UIKit.UIView {
  func didSelect()
}
extension UIKit.NSLayoutConstraint {
  @_Concurrency.MainActor(unsafe) public static func activate(_ constraints: [UIKit.NSLayoutConstraint?])
  @_Concurrency.MainActor(unsafe) public static func deactivate(_ constraints: [UIKit.NSLayoutConstraint?])
}
public protocol ElementStyle : Swift.Decodable {
  var id: Swift.String { get }
  var basicProps: Treasure.ElementStyleProps? { get }
}
public protocol ItemStyling {
}
public enum ElementStyleType : Swift.String {
  case screen
  case label
  case image
  case button
  case titleSubtitle
  case basicListItem
  case divider
  case group
  case card
  case navBar
  case designSystem
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AnyElementStyle : Swift.Decodable {
  case screen(Treasure.TreasureScreenStyle)
  case label(Treasure.LabelElementStyle)
  case image(Treasure.ImageElementStyle)
  case button(Treasure.ButtonElementStyle)
  case titleSubtitle(Treasure.TitleSubtitleElementStyle)
  case basicListItem(Treasure.BasicListItemElementStyle)
  case divider(Treasure.DividerElementStyle)
  case group(Treasure.GroupElementStyle)
  case card(Treasure.CardContainerElementStyle)
  case navBar(Treasure.NavBarElementStyle)
  case designSystem(Treasure.DesignSystemStyle)
  case none
  public init(from decoder: Swift.Decoder) throws
  public var value: Treasure.ElementStyle? {
    get
  }
}
public protocol ElementStyleDecoder {
  func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct UnsupportedElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct ScreenElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct TitleElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct ImageElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct ButtonElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct TitleSubtitleElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct BasicListItemElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct GroupElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct DividerElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct CardContainerElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct NavBarElementStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public struct DesignSystemStyleDecoder : Treasure.ElementStyleDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyElementStyle
}
public enum AnyTreasureElementStyleDecoder {
}
@objc @_Concurrency.MainActor(unsafe) open class CollectionView : UIKit.UICollectionView {
  @_Concurrency.MainActor(unsafe) public init(layout: UIKit.UICollectionViewLayout, configuration: Treasure.CollectionViewConfiguration = .shared)
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToWindow()
  public enum UpdateStrategy {
    case animatedBatchUpdates
    case nonanimatedBatchUpdates
    case reloadData
    public static func == (a: Treasure.CollectionView.UpdateStrategy, b: Treasure.CollectionView.UpdateStrategy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) weak public var accessibilityDelegate: Treasure.CollectionViewAccessibilityDelegate?
  @_Concurrency.MainActor(unsafe) weak public var scrollDelegate: UIKit.UIScrollViewDelegate?
  @_Concurrency.MainActor(unsafe) weak public var layoutDelegate: Swift.AnyObject?
  @_Concurrency.MainActor(unsafe) weak public var displayDelegate: Treasure.CollectionViewDisplayDelegate?
  @_Concurrency.MainActor(unsafe) weak public var transitionLayoutDelegate: Treasure.CollectionViewTransitionLayoutDelegate?
  @_Concurrency.MainActor(unsafe) weak public var reorderingDelegate: Treasure.CollectionViewReorderingDelegate?
  @_Concurrency.MainActor(unsafe) public var selectionStyle: Treasure.ItemSelectionStyle
  @_Concurrency.MainActor(unsafe) public var autoDeselectItems: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var pullToRefreshControl: UIKit.UIRefreshControl {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) weak public var prefetchDelegate: Treasure.CollectionViewPrefetchingDelegate? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var didTriggerPullToRefresh: ((UIKit.UIRefreshControl) -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var pullToRefreshEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var visibilityMetadata: Treasure.CollectionViewVisibilityMetadata {
    get
  }
  @_Concurrency.MainActor(unsafe) public func setSections(_ sections: [Treasure.SectionModel], animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func setSections(_ sections: [Treasure.SectionModel], strategy: Treasure.CollectionView.UpdateStrategy)
  @_Concurrency.MainActor(unsafe) public func scrollToItem(at path: Treasure.ItemPath, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func scrollToItem(at path: Treasure.ItemPath, position: UIKit.UICollectionView.ScrollPosition, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func setItemAsFirstResponder(at path: Treasure.ItemPath)
  @_Concurrency.MainActor(unsafe) public func moveAccessibilityFocusToItem(at path: Treasure.ItemPath, notification: UIKit.UIAccessibility.Notification = .layoutChanged)
  @_Concurrency.MainActor(unsafe) public func moveAccessibilityFocusToLastFocusedElement()
  @_Concurrency.MainActor(unsafe) public func selectItem(at path: Treasure.ItemPath, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func deselectItem(at path: Treasure.ItemPath, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func section(at dataID: Swift.AnyHashable) -> Treasure.SectionModel?
  @_Concurrency.MainActor(unsafe) public func item(at path: Treasure.ItemPath) -> Treasure.AnyItemModel?
  @_Concurrency.MainActor(unsafe) public func indexPathForItem(at path: Treasure.ItemPath) -> Foundation.IndexPath?
  @_Concurrency.MainActor(unsafe) public func item(at indexPath: Foundation.IndexPath) -> Treasure.AnyItemModel?
  @_Concurrency.MainActor(unsafe) public func path(for indexPath: Foundation.IndexPath) -> Treasure.ItemPath?
  @_Concurrency.MainActor(unsafe) public func item(at point: CoreGraphics.CGPoint) -> Treasure.AnyItemModel?
  @_Concurrency.MainActor(unsafe) public func section(at index: Swift.Int) -> Treasure.SectionModel?
  @_Concurrency.MainActor(unsafe) public func reloadItem(at indexPath: Foundation.IndexPath, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func invalidateLayout()
  @objc deinit
}
extension Treasure.CollectionView : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreGraphics.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreGraphics.CGPoint>)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewShouldScrollToTop(_ scrollView: UIKit.UIScrollView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewDidScrollToTop(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewWillBeginDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView)
}
extension Treasure.CollectionView : UIKit.UICollectionViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didEndDisplaying cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplaySupplementaryView view: UIKit.UICollectionReusableView, forElementKind elementKind: Swift.String, at indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didEndDisplayingSupplementaryView view: UIKit.UICollectionReusableView, forElementOfKind elementKind: Swift.String, at indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, shouldHighlightItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didHighlightItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didUnhighlightItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, shouldSelectItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, shouldDeselectItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didDeselectItemAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, transitionLayoutForOldLayout fromLayout: UIKit.UICollectionViewLayout, newLayout toLayout: UIKit.UICollectionViewLayout) -> UIKit.UICollectionViewTransitionLayout
}
extension Treasure.CollectionView : UIKit.UICollectionViewDataSourcePrefetching {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, prefetchItemsAt indexPaths: [Foundation.IndexPath])
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cancelPrefetchingForItemsAt indexPaths: [Foundation.IndexPath])
}
extension Treasure.CollectionView {
  @available(*, unavailable, message: "You shouldn't be registering cell classes on a CollectionView. The CollectionViewDataSource handles this for you.")
  @_Concurrency.MainActor(unsafe) @objc final override public func register(_ cellClass: Swift.AnyClass?, forCellWithReuseIdentifier identifier: Swift.String)
  @available(*, unavailable, message: "You shouldn't be registering cell nibs on a CollectionView. The CollectionViewDataSource handles this for you.")
  @_Concurrency.MainActor(unsafe) @objc final override public func register(_ nib: UIKit.UINib?, forCellWithReuseIdentifier identifier: Swift.String)
  @available(*, unavailable, message: "You shouldn't be registering supplementary view nibs on a CollectionView. The CollectionViewDataSource handles this for you.")
  @_Concurrency.MainActor(unsafe) @objc final override public func register(_ nib: UIKit.UINib?, forSupplementaryViewOfKind kind: Swift.String, withReuseIdentifier identifier: Swift.String)
  @available(*, unavailable, message: "You shouldn't be registering supplementary view classes on a CollectionView. The CollectionViewDataSource handles this for you.")
  @_Concurrency.MainActor(unsafe) @objc final override public func register(_ viewClass: Swift.AnyClass?, forSupplementaryViewOfKind elementKind: Swift.String, withReuseIdentifier identifier: Swift.String)
}
public struct SetContextAction : Treasure.TreasureAction {
  public let contextId: Swift.String
  public let analytics: Treasure.TreasureAnalytics?
  public var path: Treasure.Path?
  public var value: Treasure.DynamicObject
  public init(from decoder: Swift.Decoder) throws
  public func executeAction(params: Treasure.TreasureActionParameters)
}
public enum PresentationStyle : Swift.String, Swift.Decodable {
  case system
  case wrapContent
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum NavigateAction : Treasure.TreasureAction, Swift.Decodable {
  case openExternalURL(Swift.String, analytics: Treasure.TreasureAnalytics? = nil)
  case openNativeRoute(Treasure.NavigateAction.OpenNativeRoute, analytics: Treasure.TreasureAnalytics? = nil)
  case presentView(Treasure.TreasureRoute, presentationStyle: Treasure.PresentationStyle?, analytics: Treasure.TreasureAnalytics? = nil)
  case refreshView(Treasure.TreasureRoute, analytics: Treasure.TreasureAnalytics? = nil)
  case dismissView(analytics: Treasure.TreasureAnalytics? = nil)
  case pushView(Treasure.TreasureRoute, analytics: Treasure.TreasureAnalytics? = nil)
  case popView(analytics: Treasure.TreasureAnalytics? = nil)
  public struct OpenNativeRoute : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
  public var analytics: Treasure.TreasureAnalytics? {
    get
  }
  public func executeAction(params: Treasure.TreasureActionParameters)
  public init(from decoder: Swift.Decoder) throws
}
extension Treasure.CornerRadius : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Diffable {
  func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
  var diffIdentifier: Swift.AnyHashable { get }
}
public protocol SupplementaryItemsProviding {
  typealias SupplementaryItems = [Swift.String : [Treasure.SupplementaryItemModeling]]
  var supplementaryItems: Self.SupplementaryItems { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.SupplementaryItemsProviding {
  public var supplementaryItems: Self.SupplementaryItems {
    get
    set
  }
  public func supplementaryItems(_ value: Self.SupplementaryItems) -> Self
  public func supplementaryItems(ofKind elementKind: Swift.String, _ value: [Treasure.SupplementaryItemModeling]?) -> Self
}
public protocol BottomBarsProviding {
  var bottomBars: [Treasure.BarModeling] { get }
}
public protocol TopBarsProviding {
  var topBars: [Treasure.BarModeling] { get }
}
public protocol APIEnvironment {
  var baseURL: Foundation.URL { get }
  var headers: [Swift.String : Swift.String] { get }
  var queryParameters: [Foundation.URLQueryItem] { get }
}
public protocol PresentationProviding {
  var presentation: Treasure.PresentationModel? { get }
}
final public class EpoxyLogger {
  public init(assert: @escaping Treasure.EpoxyLogger.Assert = Swift.assert, assertionFailure: @escaping Treasure.EpoxyLogger.AssertionFailure = Swift.assertionFailure, warn: @escaping Treasure.EpoxyLogger.Warn = { message, _, _ in
    })
  public typealias Assert = (_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias AssertionFailure = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Warn = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public static var shared: Treasure.EpoxyLogger
  final public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func warn(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @objc deinit
}
public protocol SetBehaviorsProviding {
}
extension Treasure.CallbackContextEpoxyModeled where Self : Treasure.SetBehaviorsProviding {
  public typealias SetBehaviors = ((Self.CallbackContext) -> Swift.Void)
  public var setBehaviors: Self.SetBehaviors? {
    get
    set
  }
  public func setBehaviors(_ value: Self.SetBehaviors?) -> Self
}
public struct TreasureScreenStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public init(from decoder: Swift.Decoder) throws
}
public struct TreasureScreen : Swift.Decodable {
  public let id: Swift.String
  public let style: Swift.String?
  public let name: Swift.String?
  public let layout: Treasure.LayoutsPerFormFactor?
  public let screenProperties: Treasure.TreasureScreenProperties?
  public init(from decoder: Swift.Decoder) throws
}
public enum ScreenModalType : Swift.String, Swift.Decodable {
  case contextSheetFitted
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct TreasureScreenProperties : Swift.Decodable {
  public let modalType: Treasure.ScreenModalType
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class TreasureDependency {
  final public var treasureLogger: Treasure.TreasureLoggerType {
    get
    set
  }
  final public var environment: Treasure.TreasureEnvironment
  final public var imageLoader: Treasure.TreasureImageLoadable?
  final public var theme: Treasure.ThemeRegistrable?
  public static let shared: Treasure.TreasureDependency
  @objc deinit
}
public struct LayoutPopulatorResult {
  public let navSections: [Treasure.BarModeling]?
  public let mainSections: [Treasure.SectionModel]
  public let footerSections: [Treasure.BarModeling]?
}
public protocol TreasureLayoutPopulator {
  func populate(layout: Treasure.SingleColumnLayout) -> Treasure.LayoutPopulatorResult
}
public protocol EphemeralCachedStateView : UIKit.UIView {
  var cachedEphemeralState: Any? { get set }
}
public protocol ItemWrapperView : UIKit.UIView {
  var view: UIKit.UIView? { get }
  func setViewIfNeeded(view: UIKit.UIView)
}
public protocol ItemCellView : Treasure.ItemWrapperView {
  var isHighlighted: Swift.Bool { get }
  var isSelected: Swift.Bool { get }
}
extension Treasure.ItemCellView {
  public var state: Treasure.ItemCellState {
    get
  }
}
public enum TreasureAnalyticsType : Swift.String {
  case eventLogging
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AnyTreasureAnalytics : Swift.Decodable {
  case eventLogging(Treasure.TreasureEventAnalytics)
  case none
  public init(from decoder: Swift.Decoder) throws
  public var value: Treasure.TreasureAnalytics? {
    get
  }
}
public protocol TreasureAnalyticsDecoder {
  func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureAnalytics
}
public struct UnsupportedAnalyticsDecoder : Treasure.TreasureAnalyticsDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureAnalytics
}
public struct EventLoggingAnalyticsDecoder : Treasure.TreasureAnalyticsDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureAnalytics
}
public enum AnyTreasureAnalyticsDecoder {
}
public struct Parser<Type> {
}
public struct AnySupplementaryItemModel : Treasure.EpoxyModeled {
  public init(_ model: Treasure.SupplementaryItemModeling)
  public var storage: Treasure.EpoxyModelStorage {
    get
    set
  }
}
extension Treasure.AnySupplementaryItemModel : Treasure.DataIDProviding {
}
extension Treasure.AnySupplementaryItemModel : Treasure.WillDisplayProviding {
}
extension Treasure.AnySupplementaryItemModel : Treasure.DidEndDisplayingProviding {
}
extension Treasure.AnySupplementaryItemModel : Treasure.SetContentProviding {
}
extension Treasure.AnySupplementaryItemModel : Treasure.SetBehaviorsProviding {
}
extension Treasure.AnySupplementaryItemModel : Treasure.StyleIDProviding {
}
extension Treasure.AnySupplementaryItemModel : Treasure.SupplementaryItemModeling {
  public func eraseToAnySupplementaryItemModel() -> Treasure.AnySupplementaryItemModel
}
extension Treasure.AnySupplementaryItemModel {
  public var viewDifferentiator: Treasure.ViewDifferentiator {
    get
  }
  public var dataID: Swift.AnyHashable {
    get
  }
}
extension Treasure.AnySupplementaryItemModel : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension Treasure.AnySupplementaryItemModel : Treasure.CallbackContextEpoxyModeled {
  public struct CallbackContext : Treasure.ViewProviding, Treasure.TraitCollectionProviding, Treasure.AnimatedProviding {
    public init(view: UIKit.UIView, traitCollection: UIKit.UITraitCollection, animated: Swift.Bool)
    public var view: UIKit.UIView
    public var traitCollection: UIKit.UITraitCollection
    public var animated: Swift.Bool
    public typealias View = UIKit.UIView
  }
}
extension Treasure.VGroup {
  public enum ItemAlignment : Swift.Hashable, Swift.Equatable {
    case fill
    case leading
    case trailing
    case center
    case centered(to: Treasure.Constrainable)
    case custom(alignmentID: Swift.AnyHashable, layoutProvider: (_ container: Treasure.Constrainable, _ constrainable: Treasure.Constrainable) -> [UIKit.NSLayoutConstraint])
    public static func == (lhs: Treasure.VGroup.ItemAlignment, rhs: Treasure.VGroup.ItemAlignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol AnchoringContainer {
  var anchor: Treasure.Constrainable { get }
}
extension Treasure.Constrainable where Self : Treasure.AnchoringContainer {
  public var leadingAnchor: UIKit.NSLayoutXAxisAnchor {
    get
  }
  public var trailingAnchor: UIKit.NSLayoutXAxisAnchor {
    get
  }
  public var leftAnchor: UIKit.NSLayoutXAxisAnchor {
    get
  }
  public var rightAnchor: UIKit.NSLayoutXAxisAnchor {
    get
  }
  public var topAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  public var bottomAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  public var widthAnchor: UIKit.NSLayoutDimension {
    get
  }
  public var heightAnchor: UIKit.NSLayoutDimension {
    get
  }
  public var centerXAnchor: UIKit.NSLayoutXAxisAnchor {
    get
  }
  public var centerYAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  public var firstBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  public var lastBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
}
public enum ElementRenderModeling {
  case item(Treasure.ItemModeling)
  case items([Treasure.ItemModeling])
  case groupItem(Treasure.GroupItemModeling)
  case barItem(Treasure.BarModeling)
  public var toItemModel: Treasure.ItemModeling? {
    get
  }
  public var toItemsModel: [Treasure.ItemModeling]? {
    get
  }
  public var toGroupModel: Treasure.GroupItemModeling? {
    get
  }
  public var toBarModel: Treasure.BarModeling? {
    get
  }
}
public struct ElementBuilderIngredients<T> where T : Treasure.TreasureElement {
  public let value: T
  public let elementID: Swift.String?
  public let renderType: Treasure.TreasureElementRenderType
  public let blueprintData: Treasure.BlueprintElement?
}
public protocol TreasureUIElementBuilder {
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.LabelElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.ImageElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.ButtonElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.DividerElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.BasicListItemElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.VGroupElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.HGroupElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.CardContainerElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.NavBarElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.BlueprintElement>) -> Treasure.ElementRenderModeling?
  func build(ingredients: Treasure.ElementBuilderIngredients<Treasure.ContextElement>) -> Treasure.ElementRenderModeling?
}
public protocol TraitCollectionProviding {
  var traitCollection: UIKit.UITraitCollection { get }
}
public struct HGroupItem : Treasure.EpoxyModeled {
  public init(dataID: Swift.AnyHashable, style: Treasure.HGroup.Style, groupItems: [Treasure.GroupItemModeling])
  public init(dataID: Swift.AnyHashable, style: Treasure.HGroup.Style, @Treasure.GroupModelBuilder _ groupItemsBuilder: () -> [Treasure.GroupItemModeling])
  public var storage: Treasure.EpoxyModelStorage
  public var style: Treasure.HGroup.Style
}
extension Treasure.HGroupItem : Treasure.AccessibilityAlignmentProviding {
}
extension Treasure.HGroupItem : Treasure.DataIDProviding {
}
extension Treasure.HGroupItem : Treasure.HorizontalAlignmentProviding {
}
extension Treasure.HGroupItem : Treasure.PaddingProviding {
}
extension Treasure.HGroupItem : Treasure.ReflowsForAccessibilityTypeSizeProviding {
}
extension Treasure.HGroupItem : Treasure.VerticalAlignmentProviding {
}
extension Treasure.HGroupItem : Treasure.GroupItemsProviding {
}
extension Treasure.HGroupItem : Treasure.GroupItemModeling {
  public func eraseToAnyGroupItem() -> Treasure.AnyGroupItem
}
extension Treasure.HGroupItem {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func makeConstrainable() -> Treasure.Constrainable
  public func update(_ constrainable: Treasure.Constrainable, animated: Swift.Bool)
  public func setBehaviors(on constrainable: Treasure.Constrainable)
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
public protocol AnimatedProviding {
  var animated: Swift.Bool { get }
}
public struct BarInstallerConfiguration {
  public init(applyBars: ((_ container: Treasure.BarContainer, _ bars: [Treasure.BarModeling], _ animated: Swift.Bool) -> Swift.Void)? = nil)
  public static var shared: Treasure.BarInstallerConfiguration
  public var applyBars: ((_ container: Treasure.BarContainer, _ bars: [Treasure.BarModeling], _ animated: Swift.Bool) -> Swift.Void)?
}
public struct SectionedChangeset {
  public init(sectionChangeset: Treasure.IndexSetChangeset, itemChangeset: Treasure.IndexPathChangeset)
  public var sectionChangeset: Treasure.IndexSetChangeset
  public var itemChangeset: Treasure.IndexPathChangeset
  public var isEmpty: Swift.Bool {
    get
  }
}
public protocol CollectionViewReorderingDelegate : AnyObject {
  func collectionView(_ collectionView: Treasure.CollectionView, moveItem sourceItem: Treasure.AnyItemModel, inSection sourceSection: Treasure.SectionModel, toDestinationItem destinationItem: Treasure.AnyItemModel, inSection destinationSection: Treasure.SectionModel)
}
public protocol UICollectionViewFlowLayoutItemSizeProvider {
  var flowLayoutItemSize: CoreGraphics.CGSize? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.UICollectionViewFlowLayoutItemSizeProvider {
  public var flowLayoutItemSize: CoreGraphics.CGSize? {
    get
    set
  }
  public func flowLayoutItemSize(_ itemSize: CoreGraphics.CGSize?) -> Self
}
extension Treasure.ItemModel : Treasure.UICollectionViewFlowLayoutItemSizeProvider {
}
extension Treasure.AnyItemModel : Treasure.UICollectionViewFlowLayoutItemSizeProvider {
}
extension Treasure.SectionModel : Treasure.UICollectionViewFlowLayoutItemSizeProvider {
}
public protocol UICollectionViewFlowLayoutSectionInsetProvider {
  var flowLayoutSectionInset: UIKit.UIEdgeInsets? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.UICollectionViewFlowLayoutSectionInsetProvider {
  public var flowLayoutSectionInset: UIKit.UIEdgeInsets? {
    get
    set
  }
  public func flowLayoutSectionInset(_ sectionInset: UIKit.UIEdgeInsets?) -> Self
}
extension Treasure.SectionModel : Treasure.UICollectionViewFlowLayoutSectionInsetProvider {
}
public protocol UICollectionViewFlowLayoutMinimumLineSpacingProvider {
  var flowLayoutMinimumLineSpacing: CoreGraphics.CGFloat? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.UICollectionViewFlowLayoutMinimumLineSpacingProvider {
  public var flowLayoutMinimumLineSpacing: CoreGraphics.CGFloat? {
    get
    set
  }
  public func flowLayoutMinimumLineSpacing(_ lineSpacing: CoreGraphics.CGFloat?) -> Self
}
extension Treasure.SectionModel : Treasure.UICollectionViewFlowLayoutMinimumLineSpacingProvider {
}
public protocol UICollectionViewFlowLayoutMinimumInteritemSpacing {
  var flowLayoutMinimumInteritemSpacing: CoreGraphics.CGFloat? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.UICollectionViewFlowLayoutMinimumInteritemSpacing {
  public var flowLayoutMinimumInteritemSpacing: CoreGraphics.CGFloat? {
    get
    set
  }
  public func flowLayoutMinimumInteritemSpacing(_ interitemSpacing: CoreGraphics.CGFloat?) -> Self
}
extension Treasure.SectionModel : Treasure.UICollectionViewFlowLayoutMinimumInteritemSpacing {
}
public protocol UICollectionViewFlowLayoutHeaderReferenceSizeProvider {
  var flowLayoutHeaderReferenceSize: CoreGraphics.CGSize? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.UICollectionViewFlowLayoutHeaderReferenceSizeProvider {
  public var flowLayoutHeaderReferenceSize: CoreGraphics.CGSize? {
    get
    set
  }
  public func flowLayoutHeaderReferenceSize(_ size: CoreGraphics.CGSize?) -> Self
}
extension Treasure.SectionModel : Treasure.UICollectionViewFlowLayoutHeaderReferenceSizeProvider {
}
public protocol UICollectionViewFlowLayoutFooterReferenceSizeProvider {
  var flowLayoutFooterReferenceSize: CoreGraphics.CGSize? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.UICollectionViewFlowLayoutFooterReferenceSizeProvider {
  public var flowLayoutFooterReferenceSize: CoreGraphics.CGSize? {
    get
    set
  }
  public func flowLayoutFooterReferenceSize(_ size: CoreGraphics.CGSize?) -> Self
}
extension Treasure.SectionModel : Treasure.UICollectionViewFlowLayoutFooterReferenceSizeProvider {
}
public protocol BarModeling {
  func eraseToAnyBarModel() -> Treasure.AnyBarModel
}
@objc final public class BottomBarInstaller : ObjectiveC.NSObject {
  public init(viewController: UIKit.UIViewController, avoidsKeyboard: Swift.Bool = false, bars: [Treasure.BarModeling] = [], configuration: Treasure.BarInstallerConfiguration = .shared)
  convenience public init(viewController: UIKit.UIViewController, avoidsKeyboard: Swift.Bool = false, @Treasure.BarModelBuilder bars: () -> [Treasure.BarModeling])
  final public var container: Treasure.BottomBarContainer? {
    get
  }
  final public var avoidsKeyboard: Swift.Bool {
    get
    set
  }
  final public func setBars(_ bars: [Treasure.BarModeling], animated: Swift.Bool)
  final public func install()
  final public func uninstall()
  @objc deinit
}
extension Treasure.BottomBarInstaller : Treasure.BarCoordinatorPropertyConfigurable {
  final public var coordinators: [Treasure.AnyBarCoordinating] {
    get
  }
  final public subscript<Property>(property: Treasure.BarCoordinatorProperty<Property>) -> Property {
    get
    set
  }
  final public func observe<Property>(_ property: Treasure.BarCoordinatorProperty<Property>, observer: @escaping (Property) -> Swift.Void) -> Swift.AnyObject
}
public struct GroupEdgeInsets : Swift.Hashable {
  public init(top: CoreGraphics.CGFloat, leading: CoreGraphics.CGFloat, bottom: CoreGraphics.CGFloat, trailing: CoreGraphics.CGFloat)
  public init(top: Treasure.GroupEdgeInsets.AdaptiveFloat, leading: Treasure.GroupEdgeInsets.AdaptiveFloat, bottom: Treasure.GroupEdgeInsets.AdaptiveFloat, trailing: Treasure.GroupEdgeInsets.AdaptiveFloat)
  public enum AdaptiveFloat : Swift.Equatable, Swift.Hashable {
    case fixed(CoreGraphics.CGFloat)
    case adaptive(compact: CoreGraphics.CGFloat, regular: CoreGraphics.CGFloat)
    case adaptiveAccessibility(compact: CoreGraphics.CGFloat, compactAccessibilitySizes: CoreGraphics.CGFloat, regular: CoreGraphics.CGFloat, regularAccessibilitySizes: CoreGraphics.CGFloat)
    public static func == (a: Treasure.GroupEdgeInsets.AdaptiveFloat, b: Treasure.GroupEdgeInsets.AdaptiveFloat) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let top: Treasure.GroupEdgeInsets.AdaptiveFloat
  public let leading: Treasure.GroupEdgeInsets.AdaptiveFloat
  public let bottom: Treasure.GroupEdgeInsets.AdaptiveFloat
  public let trailing: Treasure.GroupEdgeInsets.AdaptiveFloat
  public func edgeInsets(with traitCollection: UIKit.UITraitCollection) -> UIKit.UIEdgeInsets
  public func directionalEdgeInsets(with traitCollection: UIKit.UITraitCollection) -> UIKit.NSDirectionalEdgeInsets
  public static func == (a: Treasure.GroupEdgeInsets, b: Treasure.GroupEdgeInsets) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Treasure.GroupEdgeInsets {
  public static var zero: Treasure.GroupEdgeInsets {
    get
  }
}
extension Treasure.GroupEdgeInsets.AdaptiveFloat {
  public func value(with traitCollection: UIKit.UITraitCollection) -> CoreGraphics.CGFloat
}
public enum NVActivityIndicatorType : Swift.Int {
  case circleStrokeSpin
  case ballClipRotate
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public typealias FadeInAnimation = (UIKit.UIView) -> Swift.Void
public typealias FadeOutAnimation = (UIKit.UIView, @escaping () -> Swift.Void) -> Swift.Void
@objc @_Concurrency.MainActor(unsafe) final public class NVActivityIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_TYPE: Treasure.NVActivityIndicatorType
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_TEXT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_PADDING: CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_SIZE: CoreGraphics.CGSize
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_DISPLAY_TIME_THRESHOLD: Swift.Int
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MINIMUM_DISPLAY_TIME: Swift.Int
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE: Swift.String?
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE_SPACING: CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE_FONT: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_BACKGROUND_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_FADE_IN_ANIMATION: (_ view: UIKit.UIView) -> Swift.Void
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_FADE_OUT_ANIMATION: (_ view: UIKit.UIView, _ complete: @escaping () -> Swift.Void) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var type: Treasure.NVActivityIndicatorType
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var color: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var padding: CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) final public var isAnimating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public init(frame: CoreGraphics.CGRect, type: Treasure.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreGraphics.CGFloat? = nil, lineWidth: CoreGraphics.CGFloat = 3)
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreGraphics.CGSize {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var bounds: CoreGraphics.CGRect {
    @_Concurrency.MainActor(unsafe) @objc get
    @_Concurrency.MainActor(unsafe) @objc set
  }
  @_Concurrency.MainActor(unsafe) final public func startAnimating()
  @_Concurrency.MainActor(unsafe) final public func stopAnimating()
  @_Concurrency.MainActor(unsafe) final public func presentSuccessAnimation()
  @objc deinit
}
public protocol LogType {
  var category: Swift.String { get }
  var message: Swift.String { get }
  var level: Treasure.LogLevel { get }
}
public enum LogLevel {
  case error
  case info
  public static func == (a: Treasure.LogLevel, b: Treasure.LogLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum Log {
  case error(_: Swift.String)
  case info(_: Swift.String)
  case apiError(_: Swift.Error)
  case network(_: Treasure.Log.Network)
  case decode(_: Treasure.Log.Decoding)
  case navigation(_: Treasure.Log.Navigator)
  case cache(_: Treasure.Log.Cache)
  case expression(_: Treasure.Log.Expression)
  case customOperations(_: Treasure.Log.Operation)
  case collection(_: Treasure.Log.Collection)
  case generalError(error: Swift.Error)
  public enum Decoding {
    case decodingError(type: Swift.String)
  }
  public enum Network {
    case httpRequest(request: Treasure.Log.NetworkRequest)
    case httpResponse(response: Treasure.Log.NetworkResponse)
    case couldNotBuildUrl(url: Swift.String)
    case networkClientWasNotConfigured
  }
  public enum Navigator {
    case didReceiveAction(Treasure.NavigateAction)
    case unableToPrefetchWhenUrlIsExpression
    case didNotFindDeepLinkScreen(path: Swift.String)
    case routeDoesNotExistInTheCurrentStack(path: Swift.String)
    case didNavigateToExternalUrl(path: Swift.String)
    case invalidExternalUrl(path: Swift.String)
    case unableToOpenExternalUrl(path: Swift.String)
  }
  public enum Cache {
    case saveContext(description: Swift.String)
    case loadPersistentStores(description: Swift.String)
    case fetchData(description: Swift.String)
    case removeData(description: Swift.String)
    case clear(description: Swift.String)
  }
  public struct NetworkResponse {
    public let data: Foundation.Data?
    public let response: Foundation.URLResponse?
    public var logMessage: Swift.String {
      get
    }
    public init(data: Foundation.Data? = nil, response: Foundation.URLResponse? = nil)
  }
  public struct NetworkRequest {
    public let url: Foundation.URLRequest?
    public var logMessage: Swift.String {
      get
    }
    public init(url: Foundation.URLRequest? = nil)
  }
  public enum Expression {
    case invalidSyntax
    public static func == (a: Treasure.Log.Expression, b: Treasure.Log.Expression) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Operation {
    case alreadyExists
    case invalid(name: Swift.String)
    case notFound
  }
  public enum Collection {
    case templateNotFound(item: Swift.String)
  }
}
extension Treasure.Log : Treasure.LogType {
  public var category: Swift.String {
    get
  }
  public var message: Swift.String {
    get
  }
  public var level: Treasure.LogLevel {
    get
  }
}
public struct AnyItemModel : Treasure.EpoxyModeled {
  public init(_ model: Treasure.ItemModeling)
  public init(internalItemModel model: Treasure.InternalItemModeling)
  public var model: Treasure.InternalItemModeling
  public var storage: Treasure.EpoxyModelStorage {
    get
    set
  }
}
extension Treasure.AnyItemModel : Treasure.WillDisplayProviding {
}
extension Treasure.AnyItemModel : Treasure.DidEndDisplayingProviding {
}
extension Treasure.AnyItemModel : Treasure.DidSelectProviding {
}
extension Treasure.AnyItemModel : Treasure.SetContentProviding {
}
extension Treasure.AnyItemModel : Treasure.DidChangeStateProviding {
}
extension Treasure.AnyItemModel : Treasure.SetBehaviorsProviding {
}
extension Treasure.AnyItemModel : Treasure.StyleIDProviding {
}
extension Treasure.AnyItemModel : Treasure.ItemModeling {
  public func eraseToAnyItemModel() -> Treasure.AnyItemModel
}
extension Treasure.AnyItemModel : Treasure.InternalItemModeling {
  public var viewDifferentiator: Treasure.ViewDifferentiator {
    get
  }
  public var isSelectable: Swift.Bool {
    get
  }
  public func configuredView(traitCollection: UIKit.UITraitCollection) -> UIKit.UIView
  public func configure(cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func setBehavior(cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func configureStateChange(in cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func handleDidSelect(_ cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func handleWillDisplay(_ cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func handleDidEndDisplaying(_ cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
}
extension Treasure.AnyItemModel : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension Treasure.AnyItemModel : Treasure.CallbackContextEpoxyModeled {
  public struct CallbackContext : Treasure.ViewProviding, Treasure.TraitCollectionProviding, Treasure.AnimatedProviding {
    public init(view: UIKit.UIView, traitCollection: UIKit.UITraitCollection, state: Treasure.ItemCellState, animated: Swift.Bool)
    public init(view: UIKit.UIView, metadata: Treasure.ItemCellMetadata)
    public var view: UIKit.UIView
    public var traitCollection: UIKit.UITraitCollection
    public var state: Treasure.ItemCellState
    public var animated: Swift.Bool
    public typealias View = UIKit.UIView
  }
}
public protocol RepresentableByParsableString : Swift.Decodable, Swift.Encodable, Swift.Equatable, Swift.RawRepresentable {
  static var parser: Treasure.Parser<Self> { get }
}
extension Treasure.RepresentableByParsableString where Self.RawValue == Swift.String {
  public init?(rawValue: Self.RawValue)
}
public protocol CollectionViewTransitionLayoutDelegate : AnyObject {
  func collectionView(_ collectionView: Treasure.CollectionView, transitionLayoutForOldLayout fromLayout: UIKit.UICollectionViewLayout, newLayout toLayout: UIKit.UICollectionViewLayout) -> UIKit.UICollectionViewTransitionLayout
}
public typealias SectionModelBuilder = Treasure.EpoxyModelArrayBuilder<Treasure.SectionModel>
public protocol HostActionHandler : AnyObject {
  func setContext(context: Treasure.Context)
  func sdkActionDidComplete(actionIngredients: Treasure.ActionHandlerIngredients<Treasure.ElementsSDKAction>)
  func showLoading()
  func hideLoading()
  func presentViewController(viewController: UIKit.UIViewController)
  func dismissCurrentViewController(completion: Treasure.VoidCompletion?)
}
@objc @_Concurrency.MainActor(unsafe) open class CollectionViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public init(layout: UIKit.UICollectionViewLayout, sections: [Treasure.SectionModel]? = nil)
  @_Concurrency.MainActor(unsafe) convenience public init(layout: UIKit.UICollectionViewLayout, items: [Treasure.ItemModeling])
  @_Concurrency.MainActor(unsafe) convenience public init(layout: UIKit.UICollectionViewLayout, @Treasure.SectionModelBuilder sections: () -> [Treasure.SectionModel])
  @_Concurrency.MainActor(unsafe) convenience public init(layout: UIKit.UICollectionViewLayout, @Treasure.ItemModelBuilder items: () -> [Treasure.ItemModeling])
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) open func makeCollectionView() -> Treasure.CollectionView
  @_Concurrency.MainActor(unsafe) final public let layout: UIKit.UICollectionViewLayout
  @_Concurrency.MainActor(unsafe) public var collectionViewIfLoaded: Treasure.CollectionView? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var collectionView: Treasure.CollectionView {
    get
  }
  @_Concurrency.MainActor(unsafe) public func setSections(_ sections: [Treasure.SectionModel], animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func setItems(_ items: [Treasure.ItemModeling], animated: Swift.Bool)
  @objc deinit
}
public struct ContextElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let style: Treasure.Expression<Swift.String>?
  public let items: Treasure.Expression<[Treasure.AnyTreasureElement]>?
  public let supplementaryItems: Treasure.Expression<[Treasure.AnyTreasureElement]>?
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
public protocol Scheduler {
  func schedule(_ currentCount: Swift.UInt, closure: @escaping () -> Swift.Void) -> Swift.Bool
}
public struct ItemModel<View> : Treasure.ViewEpoxyModeled where View : UIKit.UIView {
  public init(dataID: Swift.AnyHashable)
  public init<Content>(dataID: Swift.AnyHashable, content: Content, setContent: @escaping (Treasure.ItemModel<View>.CallbackContext, Content) -> Swift.Void) where Content : Swift.Equatable
  public init<Params, Content>(dataID: Swift.AnyHashable, params: Params, content: Content, makeView: @escaping (Params) -> View, setContent: @escaping (Treasure.ItemModel<View>.CallbackContext, Content) -> Swift.Void) where Params : Swift.Hashable, Content : Swift.Equatable
  public var storage: Treasure.EpoxyModelStorage
}
extension Treasure.ItemModel : Treasure.SetContentProviding {
}
extension Treasure.ItemModel : Treasure.ErasedContentProviding {
}
extension Treasure.ItemModel : Treasure.DataIDProviding {
}
extension Treasure.ItemModel : Treasure.DidChangeStateProviding {
}
extension Treasure.ItemModel : Treasure.DidEndDisplayingProviding {
}
extension Treasure.ItemModel : Treasure.DidSelectProviding {
}
extension Treasure.ItemModel : Treasure.IsMovableProviding {
}
extension Treasure.ItemModel : Treasure.MakeViewProviding {
}
extension Treasure.ItemModel : Treasure.SelectionStyleProviding {
}
extension Treasure.ItemModel : Treasure.SetBehaviorsProviding {
}
extension Treasure.ItemModel : Treasure.StyleIDProviding {
}
extension Treasure.ItemModel : Treasure.WillDisplayProviding {
}
extension Treasure.ItemModel : Treasure.ItemModeling {
  public func eraseToAnyItemModel() -> Treasure.AnyItemModel
}
extension Treasure.ItemModel : Treasure.InternalItemModeling {
  public var viewDifferentiator: Treasure.ViewDifferentiator {
    get
  }
  public var isSelectable: Swift.Bool {
    get
  }
  public func handleWillDisplay(_ cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func handleDidEndDisplaying(_ cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func configure(cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func configureStateChange(in cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func setBehavior(cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func handleDidSelect(_ cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  public func configuredView(traitCollection: UIKit.UITraitCollection) -> UIKit.UIView
}
extension Treasure.ItemModel : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension Treasure.ItemModel : Treasure.CallbackContextEpoxyModeled {
  public struct CallbackContext : Treasure.ViewProviding, Treasure.TraitCollectionProviding, Treasure.AnimatedProviding {
    public init(view: View, traitCollection: UIKit.UITraitCollection, cellState: Treasure.ItemCellState, animated: Swift.Bool)
    public init(view: View, metadata: Treasure.ItemCellMetadata)
    public var view: View
    public var traitCollection: UIKit.UITraitCollection
    public var cellState: Treasure.ItemCellState
    public var animated: Swift.Bool
  }
}
public protocol WillDisplayProviding {
}
extension Treasure.CallbackContextEpoxyModeled where Self : Treasure.WillDisplayProviding {
  public typealias WillDisplay = ((_ context: Self.CallbackContext) -> Swift.Void)
  public var willDisplay: Self.WillDisplay? {
    get
    set
  }
  public func willDisplay(_ value: Self.WillDisplay?) -> Self
}
public struct SupplementaryItemModel<View> : Treasure.ViewEpoxyModeled where View : UIKit.UIView {
  public init(dataID: Swift.AnyHashable)
  public init<Content>(dataID: Swift.AnyHashable, content: Content, setContent: @escaping (Treasure.SupplementaryItemModel<View>.CallbackContext, Content) -> Swift.Void) where Content : Swift.Equatable
  public init<Params, Content>(dataID: Swift.AnyHashable, params: Params, content: Content, makeView: @escaping (Params) -> View, setContent: @escaping (Treasure.SupplementaryItemModel<View>.CallbackContext, Content) -> Swift.Void) where Params : Swift.Hashable, Content : Swift.Equatable
  public var storage: Treasure.EpoxyModelStorage
}
extension Treasure.SupplementaryItemModel : Treasure.SetContentProviding {
}
extension Treasure.SupplementaryItemModel : Treasure.ErasedContentProviding {
}
extension Treasure.SupplementaryItemModel : Treasure.DataIDProviding {
}
extension Treasure.SupplementaryItemModel : Treasure.DidEndDisplayingProviding {
}
extension Treasure.SupplementaryItemModel : Treasure.MakeViewProviding {
}
extension Treasure.SupplementaryItemModel : Treasure.SetBehaviorsProviding {
}
extension Treasure.SupplementaryItemModel : Treasure.StyleIDProviding {
}
extension Treasure.SupplementaryItemModel : Treasure.WillDisplayProviding {
}
extension Treasure.SupplementaryItemModel : Treasure.SupplementaryItemModeling {
  public func eraseToAnySupplementaryItemModel() -> Treasure.AnySupplementaryItemModel
}
extension Treasure.SupplementaryItemModel {
  public var viewDifferentiator: Treasure.ViewDifferentiator {
    get
  }
  public func configure(reusableView: Treasure.CollectionViewReusableView, traitCollection: UIKit.UITraitCollection, animated: Swift.Bool)
  public func setBehavior(reusableView: Treasure.CollectionViewReusableView, traitCollection: UIKit.UITraitCollection, animated: Swift.Bool)
}
extension Treasure.SupplementaryItemModel : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension Treasure.SupplementaryItemModel : Treasure.CallbackContextEpoxyModeled {
  public struct CallbackContext : Treasure.ViewProviding, Treasure.TraitCollectionProviding, Treasure.AnimatedProviding {
    public init(view: View, traitCollection: UIKit.UITraitCollection, animated: Swift.Bool)
    public var view: View
    public var traitCollection: UIKit.UITraitCollection
    public var animated: Swift.Bool
  }
}
public struct HGroupElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let style: Treasure.Expression<Swift.String>?
  public let items: [Treasure.AnyTreasureElement]?
  public let onPressAction: Treasure.AnyTreasureAction?
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
public struct Context : Swift.Equatable, Swift.Codable {
  public let id: Swift.String
  public let value: Treasure.DynamicObject
  public init(id: Swift.String, value: Treasure.DynamicObject)
  public static func == (a: Treasure.Context, b: Treasure.Context) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol GroupItemModeling : Treasure.Diffable {
  func eraseToAnyGroupItem() -> Treasure.AnyGroupItem
}
extension Swift.Array where Element == Treasure.GroupItemModeling {
  public func eraseToAnyGroupItems() -> [Treasure.AnyGroupItem]
}
public struct LayoutMargins : Swift.Decodable {
  public let values: [Swift.Double]
  public init(values: [Swift.Double])
  public init(from decoder: Swift.Decoder) throws
}
final public class ReuseIDStore {
  public init()
  final public func reuseID(byRegistering viewDifferentiator: Treasure.ViewDifferentiator) -> Swift.String
  final public func registeredReuseID(for viewDifferentiator: Treasure.ViewDifferentiator) -> Swift.String?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class CollectionViewCell : UIKit.UICollectionViewCell, Treasure.ItemCellView {
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) final public var view: UIKit.UIView? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var selectedBackgroundColor: UIKit.UIColor?
  @_Concurrency.MainActor(unsafe) @objc override final public var isSelected: Swift.Bool {
    @_Concurrency.MainActor(unsafe) @objc get
    @_Concurrency.MainActor(unsafe) @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var isHighlighted: Swift.Bool {
    @_Concurrency.MainActor(unsafe) @objc get
    @_Concurrency.MainActor(unsafe) @objc set
  }
  @_Concurrency.MainActor(unsafe) final public func setViewIfNeeded(view: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) @objc override final public func preferredLayoutAttributesFitting(_ layoutAttributes: UIKit.UICollectionViewLayoutAttributes) -> UIKit.UICollectionViewLayoutAttributes
  @_Concurrency.MainActor(unsafe) @objc override final public func prepareForReuse()
  @objc deinit
}
extension Treasure.CollectionViewCell : Treasure.EphemeralCachedStateView {
  @_Concurrency.MainActor(unsafe) final public var cachedEphemeralState: Any? {
    get
    set
  }
}
extension Treasure.CollectionViewCell {
  @objc override final public var accessibilityElementsHidden: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override final public func accessibilityElementDidBecomeFocused()
  @objc override final public func accessibilityElementDidLoseFocus()
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class BottomBarContainer : Treasure.BarStackView {
  @objc required dynamic public init()
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) required public init(style: Swift.Never)
  @_Concurrency.MainActor(unsafe) @objc override final public var center: CoreGraphics.CGPoint {
    @_Concurrency.MainActor(unsafe) @objc get
    @_Concurrency.MainActor(unsafe) @objc set
  }
  @_Concurrency.MainActor(unsafe) final public var insetBehavior: Treasure.BarContainerInsetBehavior {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) weak final public var viewController: UIKit.UIViewController? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var insetMargins: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var bottomOffset: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func didMoveToSuperview()
  @_Concurrency.MainActor(unsafe) final public func add(to superview: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) final public func remove()
  @objc deinit
}
public struct EpoxyModelStorage {
  public init()
  public subscript<Property>(property: Treasure.EpoxyModelProperty<Property>) -> Property {
    get
    set
  }
  public mutating func merge(_ other: Treasure.EpoxyModelStorage)
}
public struct SectionModel : Treasure.EpoxyModeled {
  public init(dataID: Swift.AnyHashable? = nil, items: [Treasure.ItemModeling])
  public init(dataID: Swift.AnyHashable? = nil, @Treasure.ItemModelBuilder items: () -> [Treasure.ItemModeling])
  public var storage: Treasure.EpoxyModelStorage
}
extension Treasure.SectionModel : Treasure.DataIDProviding {
}
extension Treasure.SectionModel : Treasure.DidEndDisplayingProviding {
}
extension Treasure.SectionModel : Treasure.ItemsProviding {
}
extension Treasure.SectionModel : Treasure.SupplementaryItemsProviding {
}
extension Treasure.SectionModel : Treasure.WillDisplayProviding {
}
extension Treasure.SectionModel : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension Treasure.SectionModel : Treasure.DiffableSection {
  public var diffableItems: [Treasure.AnyItemModel] {
    get
  }
  public typealias DiffableItems = [Treasure.AnyItemModel]
}
extension Treasure.SectionModel : Treasure.CallbackContextEpoxyModeled {
  public typealias CallbackContext = Swift.Void
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class VGroupView : UIKit.UIView, Treasure.EpoxyableView {
  @_Concurrency.MainActor(unsafe) public init(style: Treasure.VGroupView.Style)
  public struct Style : Swift.Hashable {
    public init(vGroupStyle: Treasure.VGroup.Style = .init(), edgeInsets: Treasure.GroupEdgeInsets = .zero)
    public var vGroupStyle: Treasure.VGroup.Style
    public var edgeInsets: Treasure.GroupEdgeInsets
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Treasure.VGroupView.Style, b: Treasure.VGroupView.Style) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Content : Swift.Equatable {
    public init(items: [Treasure.GroupItemModeling])
    public init(@Treasure.GroupModelBuilder _ itemBuilder: () -> [Treasure.GroupItemModeling])
    public var items: [Treasure.AnyGroupItem]
    public static func == (lhs: Treasure.VGroupView.Content, rhs: Treasure.VGroupView.Content) -> Swift.Bool
  }
  @_Concurrency.MainActor(unsafe) final public func setContent(_ content: Treasure.VGroupView.Content, animated: Swift.Bool)
  public typealias Behaviors = Swift.Never
  @objc deinit
}
public struct AnyBarModel : Treasure.EpoxyModeled {
  public var storage: Treasure.EpoxyModelStorage {
    get
    set
  }
}
extension Treasure.AnyBarModel : Treasure.BarModeling {
  public func eraseToAnyBarModel() -> Treasure.AnyBarModel
}
extension Treasure.AnyBarModel : Treasure.DataIDProviding {
}
extension Treasure.AnyBarModel : Treasure.StyleIDProviding {
}
extension Treasure.AnyBarModel : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
public enum DynamicObject : Swift.Equatable, Swift.Hashable {
  case empty
  case bool(Swift.Bool)
  case int(Swift.Int)
  case double(Swift.Double)
  case string(Swift.String)
  case array([Treasure.DynamicObject])
  case dictionary(Treasure.DynamicDictionary)
  case expression(Treasure.ContextExpression)
  public init<T>(_ object: T) where T : Swift.Encodable
  public static func == (a: Treasure.DynamicObject, b: Treasure.DynamicObject) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias DynamicDictionary = [Swift.String : Treasure.DynamicObject]
extension Treasure.DynamicObject : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public func asAny() -> Any?
  public func asDictionary() -> Treasure.DynamicDictionary
  public func isEqualIgnoringAssociatedValues(_ anotherObject: Treasure.DynamicObject) -> Swift.Bool
}
extension Treasure.DynamicObject : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Treasure.DynamicObject : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
public class KeyboardPositionWatcher {
  public init()
  public var enabled: Swift.Bool {
    get
    set
  }
  public func observeOverlap(in containingView: UIKit.UIView?, _ observer: @escaping (_ overlap: CoreGraphics.CGFloat) -> Swift.Void)
  public func adjustBottomContentInset(of scrollView: UIKit.UIScrollView?)
  public func stopObserving(in containingView: UIKit.UIView?)
  @objc deinit
}
extension UIKit.UIScrollView {
  @nonobjc @_Concurrency.MainActor(unsafe) public var keyboardAdjustsBottomContentInset: Swift.Bool {
    get
    set
  }
  @nonobjc @_Concurrency.MainActor(unsafe) public var keyboardContentInsetAdjustment: CoreGraphics.CGFloat? {
    get
  }
}
extension UIKit.UIViewController {
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func withNavigation() -> UIKit.UINavigationController
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func withPresentation(_ presentation: UIKit.UIModalPresentationStyle) -> Self
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func withTransition(_ transition: UIKit.UIModalTransitionStyle) -> Self
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func withNavigationStyle(_ navigationStyle: Treasure.NavigationStyle) -> UIKit.UIViewController
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func withStyles(navigation: Treasure.NavigationStyle, presentation: UIKit.UIModalPresentationStyle, transition: UIKit.UIModalTransitionStyle) -> UIKit.UIViewController
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func presentController(_ controller: UIKit.UIViewController, type: Treasure.PresentationType, animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func dismissController(animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
}
public struct DesignSystemStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public init(from decoder: Swift.Decoder) throws
}
extension Treasure.TreasureView {
  public init(context: Treasure.Context? = nil, screens: [Treasure.TreasureScreen], sections: [Treasure.TreasureSection], blueprints: [Treasure.TreasureElement], styles: [Treasure.ElementStyle])
}
public enum BottomLineVisibility : Swift.String, Swift.Decodable {
  case hidden
  case alwaysVisible
  case visibleByContentOffset
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct NavBarElementStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public let titleStyleId: Swift.String?
  public let imageStyleId: Swift.String?
  public let height: Swift.Double?
  public let bottomLineColor: Swift.String?
  public let bottomLineHeight: Swift.Double?
  public let bottomLineVisibility: Treasure.BottomLineVisibility?
  public init(id: Swift.String, basicProps: Treasure.ElementStyleProps? = nil, titleStyleId: Swift.String? = nil, imageStyleId: Swift.String? = nil, height: Swift.Double? = nil, bottomLineColor: Swift.String? = nil, bottomLineHeight: Swift.Double? = nil, bottomLineVisibility: Treasure.BottomLineVisibility? = nil)
  public init(from decoder: Swift.Decoder) throws
}
public struct NavBarElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let style: Treasure.Expression<Swift.String>?
  public let title: Treasure.Expression<Swift.String>?
  public let image: Treasure.Expression<Treasure.TreasureImageSource>?
  public init(id: Swift.String, style: Treasure.Expression<Swift.String>? = nil, title: Treasure.Expression<Swift.String>? = nil, image: Treasure.Expression<Treasure.TreasureImageSource>? = nil)
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
@objc @_Concurrency.MainActor(unsafe) final public class Spacer : UIKit.UILayoutGuide, Treasure.Constrainable {
  @_Concurrency.MainActor(unsafe) public init(style: Treasure.Spacer.Style)
  @_Concurrency.MainActor(unsafe) convenience public init(minHeight: CoreGraphics.CGFloat? = nil, minWidth: CoreGraphics.CGFloat? = nil, maxHeight: CoreGraphics.CGFloat? = nil, maxWidth: CoreGraphics.CGFloat? = nil, fixedHeight: CoreGraphics.CGFloat? = nil, fixedWidth: CoreGraphics.CGFloat? = nil)
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  public struct Style : Swift.Hashable {
    public init(minHeight: CoreGraphics.CGFloat? = nil, minWidth: CoreGraphics.CGFloat? = nil, maxHeight: CoreGraphics.CGFloat? = nil, maxWidth: CoreGraphics.CGFloat? = nil, fixedHeight: CoreGraphics.CGFloat? = nil, fixedWidth: CoreGraphics.CGFloat? = nil)
    public var minHeight: CoreGraphics.CGFloat?
    public var minWidth: CoreGraphics.CGFloat?
    public var maxHeight: CoreGraphics.CGFloat?
    public var maxWidth: CoreGraphics.CGFloat?
    public var fixedHeight: CoreGraphics.CGFloat?
    public var fixedWidth: CoreGraphics.CGFloat?
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Treasure.Spacer.Style, b: Treasure.Spacer.Style) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) final public let style: Treasure.Spacer.Style
  @_Concurrency.MainActor(unsafe) final public var firstBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var lastBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  @_Concurrency.MainActor(unsafe) final public func install(in view: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) final public func uninstall()
  @_Concurrency.MainActor(unsafe) final public func isEqual(to constrainable: Treasure.Constrainable) -> Swift.Bool
  @objc deinit
}
public enum SystemThemeType {
  case dark
  case light
  public static func == (a: Treasure.SystemThemeType, b: Treasure.SystemThemeType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class ThemeComponent<T> {
  final public let values: [Swift.String : [Treasure.SystemThemeType : T]]
  public init(values: [Swift.String : [Treasure.SystemThemeType : T]])
  @objc deinit
}
public protocol ThemeRegistrable {
  var fonts: Treasure.ThemeComponent<UIKit.UIFont>? { get set }
  var colors: Treasure.ThemeComponent<UIKit.UIColor>? { get set }
  var images: Treasure.ThemeComponent<UIKit.UIImage>? { get set }
  var styles: [Swift.String : Treasure.ElementStyle]? { get set }
}
public struct DividerElementStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public let width: Swift.Double?
  public let height: Swift.Double?
  public let color: Swift.String?
  public init(id: Swift.String, basicProps: Treasure.ElementStyleProps? = nil, width: Swift.Double? = nil, height: Swift.Double? = nil, color: Swift.String? = nil)
  public init(from decoder: Swift.Decoder) throws
}
public struct DividerElement : Treasure.TreasureElement {
  public let style: Treasure.Expression<Swift.String>?
  public let id: Swift.String
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
public protocol TreasureAnalytics : Swift.Decodable {
  var loggingID: Swift.String { get }
}
public struct TreasureEventAnalytics : Treasure.TreasureAnalytics {
  public let loggingID: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public protocol Group : Treasure.Constrainable {
  var items: [Treasure.AnyGroupItem] { get }
  func setItems(_ newItems: [Treasure.GroupItemModeling], animated: Swift.Bool)
  func setItems(@Treasure.GroupModelBuilder _ buildItems: () -> [Treasure.GroupItemModeling], animated: Swift.Bool)
  func constrainable(with dataID: Swift.AnyHashable) -> Treasure.Constrainable?
  func groupItem(with dataID: Swift.AnyHashable) -> Treasure.AnyGroupItem?
}
public protocol SupplementaryItemModeling {
  func eraseToAnySupplementaryItemModel() -> Treasure.AnySupplementaryItemModel
}
@objc @_Concurrency.MainActor(unsafe) final public class VGroup : UIKit.UILayoutGuide, Treasure.Constrainable {
  @_Concurrency.MainActor(unsafe) public init(style: Treasure.VGroup.Style = .init(), items: [Treasure.GroupItemModeling] = [])
  @_Concurrency.MainActor(unsafe) convenience public init(alignment: Treasure.VGroup.ItemAlignment = .fill, spacing: CoreGraphics.CGFloat = 0, items: [Treasure.GroupItemModeling] = [])
  @_Concurrency.MainActor(unsafe) convenience public init(style: Treasure.VGroup.Style = .init(), @Treasure.GroupModelBuilder _ content: () -> [Treasure.GroupItemModeling])
  @_Concurrency.MainActor(unsafe) convenience public init(alignment: Treasure.VGroup.ItemAlignment = .fill, spacing: CoreGraphics.CGFloat = 0, @Treasure.GroupModelBuilder _ content: () -> [Treasure.GroupItemModeling])
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  public struct Style : Swift.Hashable {
    public init(alignment: Treasure.VGroup.ItemAlignment = .fill, spacing: CoreGraphics.CGFloat = 0)
    public static func == (a: Treasure.VGroup.Style, b: Treasure.VGroup.Style) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) final public let alignment: Treasure.VGroup.ItemAlignment
  @_Concurrency.MainActor(unsafe) final public var items: [Treasure.AnyGroupItem] {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var spacing: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var firstBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var lastBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  @_Concurrency.MainActor(unsafe) final public func setItems(_ newItems: [Treasure.GroupItemModeling], animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) final public func setItems(@Treasure.GroupModelBuilder _ buildItems: () -> [Treasure.GroupItemModeling], animated: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) final public func constrainable(with dataID: Swift.AnyHashable) -> Treasure.Constrainable?
  @_Concurrency.MainActor(unsafe) final public func groupItem(with dataID: Swift.AnyHashable) -> Treasure.AnyGroupItem?
  @_Concurrency.MainActor(unsafe) final public func install(in view: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) final public func uninstall()
  @_Concurrency.MainActor(unsafe) final public func isEqual(to constrainable: Treasure.Constrainable) -> Swift.Bool
  @objc deinit
}
public struct Binding {
  public let context: Swift.String
  public let path: Treasure.Path
  public init(context: Swift.String, path: Treasure.Path)
}
extension Treasure.Binding : Treasure.RepresentableByParsableString {
  public static let parser: Treasure.Parser<Treasure.Binding>
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
@objc final public class TopBarInstaller : ObjectiveC.NSObject {
  public init(viewController: UIKit.UIViewController, bars: [Treasure.BarModeling] = [], configuration: Treasure.BarInstallerConfiguration = .shared)
  convenience public init(viewController: UIKit.UIViewController, @Treasure.BarModelBuilder bars: () -> [Treasure.BarModeling])
  final public var container: Treasure.TopBarContainer? {
    get
  }
  final public func setBars(_ bars: [Treasure.BarModeling], animated: Swift.Bool)
  final public func install()
  final public func uninstall()
  @objc deinit
}
extension Treasure.TopBarInstaller : Treasure.BarCoordinatorPropertyConfigurable {
  final public var coordinators: [Treasure.AnyBarCoordinating] {
    get
  }
  final public subscript<Property>(property: Treasure.BarCoordinatorProperty<Property>) -> Property {
    get
    set
  }
  final public func observe<Property>(_ property: Treasure.BarCoordinatorProperty<Property>, observer: @escaping (Property) -> Swift.Void) -> Swift.AnyObject
}
public struct CornerRadius : Swift.Decodable {
  public let topLeft: Swift.Double?
  public let topRight: Swift.Double?
  public let bottomLeft: Swift.Double?
  public let bottomRight: Swift.Double?
  public init(topLeft: Swift.Double? = nil, topRight: Swift.Double? = nil, bottomLeft: Swift.Double? = nil, bottomRight: Swift.Double? = nil)
  public init(from decoder: Swift.Decoder) throws
}
public struct ElementStyleProps : Swift.Decodable {
  public let backgroundColor: Swift.String?
  public let borderColor: Swift.String?
  public let borderWidth: Swift.Double?
  public let layoutMargins: Treasure.LayoutMargins?
  public let cornerRadius: Swift.Double?
  public let specificCornerRadius: Treasure.CornerRadius?
  public init(backgroundColor: Swift.String? = nil, borderColor: Swift.String? = nil, borderWidth: Swift.Double? = nil, layoutMargins: Treasure.LayoutMargins? = nil, cornerRadius: Swift.Double? = nil, specificCornerRadius: Treasure.CornerRadius? = nil)
  public init(from decoder: Swift.Decoder) throws
}
extension UIKit.UIViewController {
  @nonobjc @_Concurrency.MainActor(unsafe) public func setPresentation(_ model: Treasure.PresentationModel?, animated: Swift.Bool)
}
public protocol AnyBarCoordinating : AnyObject {
  var backing: Treasure.AnyBarCoordinating { get }
}
extension Treasure.AnyBarCoordinating {
  public var backing: Treasure.AnyBarCoordinating {
    get
  }
}
public protocol BarCoordinating : Treasure.AnyBarCoordinating {
  associatedtype Model : Treasure.BarModeling
  func barModel(for model: Self.Model) -> Treasure.BarModeling
}
public protocol CollectionViewPrefetchingDelegate : AnyObject {
  func collectionView(_ collectionView: Treasure.CollectionView, prefetch items: [Treasure.AnyItemModel])
  func collectionView(_ collectionView: Treasure.CollectionView, cancelPrefetchingOf items: [Treasure.AnyItemModel])
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func addShadow(size: CoreGraphics.CGSize = CGSize(width: 0, height: 4), radius: CoreGraphics.CGFloat = 20, shadowColor: UIKit.UIColor = UIColor(hexString: "#x878883")!, shadowOpacity: Swift.Float = 0.25, viewCornerRadius: CoreGraphics.CGFloat = 0)
  @_Concurrency.MainActor(unsafe) public func dropShadow(shadowColor: UIKit.UIColor = UIColor(hexString: "#878883")!, fillColor _: UIKit.UIColor = UIColor.white, opacity: Swift.Float = 0.25, offset: CoreGraphics.CGSize = CGSize(width: 0.0, height: 4), radius: CoreGraphics.CGFloat = 4)
  @_Concurrency.MainActor(unsafe) public func roundCorners(corners: UIKit.UIRectCorner, radius: CoreGraphics.CGFloat)
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func addShadowCoreUI(size: CoreGraphics.CGSize = CGSize(width: 0, height: 10), radius: CoreGraphics.CGFloat = 20, shadowColor: UIKit.UIColor = .black, shadowOpacity: Swift.Float = 0.36, viewCornerRadius: CoreGraphics.CGFloat = 0)
  @_Concurrency.MainActor(unsafe) public func addRoundedCorners(corners: UIKit.UIRectCorner, radius: CoreGraphics.CGFloat)
  public struct Border : Swift.OptionSet {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = UIKit.UIView.Border
    public typealias Element = UIKit.UIView.Border
    public typealias RawValue = Swift.Int
  }
  @_Concurrency.MainActor(unsafe) public func setBorder(_ border: UIKit.UIView.Border, color: UIKit.UIColor, borderWidth: CoreGraphics.CGFloat)
}
extension QuartzCore.CALayer {
  public func addShadow(size: CoreGraphics.CGSize = CGSize(width: 0, height: 4), radius: CoreGraphics.CGFloat = 8)
}
extension UIKit.UIColor {
  public func toHexString() -> Swift.String
}
extension UIKit.UIImage {
  public func resizeWithPercent(percentage: CoreGraphics.CGFloat) -> UIKit.UIImage?
  public func jpegData(with resizePercentage: CoreGraphics.CGFloat, compressionQuality: CoreGraphics.CGFloat) -> Foundation.Data?
}
extension UIKit.UILabel {
  @_Concurrency.MainActor(unsafe) public func setAttributedText(attributedText: Foundation.NSAttributedString, lineBreakMode: UIKit.NSLineBreakMode = NSLineBreakMode.byTruncatingTail)
  @_Concurrency.MainActor(unsafe) public func sizeForSingleLine(minimumScaleFactor: CoreGraphics.CGFloat = 0.3)
  @_Concurrency.MainActor(unsafe) public func sizeLabelText(adjustsFontSizeToFitWidth: Swift.Bool = true, allowsDefaultTighteningForTruncation: Swift.Bool = false, baselineAdjustment: UIKit.UIBaselineAdjustment = UIBaselineAdjustment.alignBaselines, minimumScaleFactor: CoreGraphics.CGFloat = 0.3, numberOfLines: Swift.Int = 1)
}
public struct VGroupElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let style: Treasure.Expression<Swift.String>?
  public let items: [Treasure.AnyTreasureElement]?
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
public struct ButtonElementStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public let textColor: Treasure.ColorSource?
  public let textFont: Treasure.FontSource?
  public let alignment: Treasure.TextLabelAlignment?
  public let buttonHeight: Swift.Double?
  public init(from decoder: Swift.Decoder) throws
}
public struct ButtonElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let title: Treasure.Expression<Swift.String>?
  public let image: Treasure.Expression<Treasure.TreasureImageSource>?
  public let style: Treasure.Expression<Swift.String>?
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
public enum FontSource : Swift.Decodable {
  case designSystem(Swift.String)
  case provided(Treasure.FontData)
  public init(from decoder: Swift.Decoder) throws
}
public struct FontData : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class ElementStyleUIKitConverter {
  public static let shared: Treasure.ElementStyleUIKitConverter
  @objc deinit
}
extension Treasure.LayoutMargins {
  public var inset: UIKit.UIEdgeInsets {
    get
  }
  public var groupEdgeInsets: Treasure.GroupEdgeInsets {
    get
  }
  public var toNSDirectionalEdgeInsets: UIKit.NSDirectionalEdgeInsets {
    get
  }
}
extension Treasure.TextLabelAlignment {
  public var toNSAlignment: UIKit.NSTextAlignment {
    get
  }
}
extension Treasure.ImageContentMode {
  public var toUIViewMode: UIKit.UIView.ContentMode {
    get
  }
}
extension Treasure.HGroupContentAlignment {
  public var alignment: Treasure.HGroup.ItemAlignment {
    get
  }
}
extension Treasure.VGroupContentAlignment {
  public var alignment: Treasure.VGroup.ItemAlignment {
    get
  }
}
extension Treasure.CollectionSectionItemLayoutSize {
  @available(iOS 13.0, *)
  public func toNSCollectionLayoutDimension(forHeight: Swift.Bool) -> UIKit.NSCollectionLayoutDimension
}
extension Treasure.TreasureLayoutOrthogonalScrollingType {
  @available(iOS 13.0, *)
  public var toBehavior: UIKit.UICollectionLayoutSectionOrthogonalScrollingBehavior {
    get
  }
}
extension Treasure.FontData {
  public var toUIFont: UIKit.UIFont {
    get
  }
}
extension Treasure.FontSource {
  public var toUIFont: UIKit.UIFont {
    get
  }
}
extension Treasure.ColorSource {
  public var toUIColor: UIKit.UIColor {
    get
  }
}
public enum ItemCellState {
  case normal
  case highlighted
  case selected
  public static func == (a: Treasure.ItemCellState, b: Treasure.ItemCellState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TreasureHostActionHandler : AnyObject {
  func handle(externalAction: Treasure.ExternalAction)
}
public protocol TreasureHostSDKActionHandler : AnyObject {
  func handle(sdkAction: Treasure.ActionHandlerIngredients<Treasure.ElementsSDKAction>)
}
final public class TreasureConfiguration {
  final public let environment: Treasure.TreasureEnvironment
  public init(environment: Treasure.TreasureEnvironment)
  @objc deinit
}
final public class TreasureHost {
  final public var rootNavigationController: UIKit.UINavigationController? {
    get
  }
  weak final public var hostActionHandler: Treasure.TreasureHostActionHandler?
  weak final public var sdkActionHandler: Treasure.TreasureHostSDKActionHandler?
  final public var internalOperationHandler: Treasure.HostActionHandler? {
    get
  }
  public init(configuration: Treasure.TreasureConfiguration)
  final public func loadFromLocal(filePath: Swift.String) -> UIKit.UIViewController
  final public func loadFromCheckoutUI(completion: @escaping (UIKit.UIViewController) -> Swift.Void)
  final public func pushViewController(vc: UIKit.UIViewController)
  @objc deinit
}
public protocol DiffableSection : Treasure.Diffable {
  associatedtype DiffableItems : Swift.Collection where Self.DiffableItems.Element : Treasure.Diffable, Self.DiffableItems.Index == Swift.Int
  var diffableItems: Self.DiffableItems { get }
}
public struct CollectionViewConfiguration {
  public init(usesBatchUpdatesForAllReloads: Swift.Bool = true, usesCellPrefetching: Swift.Bool = true, usesAccurateScrollToItem: Swift.Bool = true)
  public static var shared: Treasure.CollectionViewConfiguration
  public var usesBatchUpdatesForAllReloads: Swift.Bool
  public var usesCellPrefetching: Swift.Bool
  public var usesAccurateScrollToItem: Swift.Bool
}
public struct TreasureAPIError : Swift.Decodable, Swift.Error, Foundation.LocalizedError {
  public var status: Swift.Int?
  public let errorCode: Swift.String
  public let errorMessage: Swift.String
  public let type: Treasure.APIErrorType
  public var errorDescription: Swift.String? {
    get
  }
  public init(status: Swift.Int?, errorCode: Swift.String, errorMessage: Swift.String, type: Treasure.APIErrorType)
  public init(from decoder: Swift.Decoder) throws
}
public enum APIErrorType : Swift.String, Swift.Decodable {
  case cardError
  case apiError
  case authenticationError
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias ItemModelBuilder = Treasure.EpoxyModelArrayBuilder<Treasure.ItemModeling>
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class HalfModalPresentationController : UIKit.UIPresentationController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(presentedViewController: UIKit.UIViewController, presenting presentingViewController: UIKit.UIViewController?)
  @_Concurrency.MainActor(unsafe) @objc override final public func presentationTransitionWillBegin()
  @_Concurrency.MainActor(unsafe) @objc override final public func dismissalTransitionWillBegin()
  @_Concurrency.MainActor(unsafe) @objc override final public var adaptivePresentationStyle: UIKit.UIModalPresentationStyle {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var shouldPresentInFullscreen: Swift.Bool {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func size(forChildContentContainer container: UIKit.UIContentContainer, withParentContainerSize parentSize: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  @_Concurrency.MainActor(unsafe) @objc override final public func containerViewWillLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public var frameOfPresentedViewInContainerView: CoreGraphics.CGRect {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @objc deinit
}
public struct FetchContextRequest : Treasure.TreasureAPIRequest {
  public typealias ResponseType = Treasure.FetchContextResponse
  public var path: Swift.String {
    get
  }
  public var counter: Swift.UInt
  public var method: Treasure.HttpMethod
  public var queryParameters: [Foundation.URLQueryItem]
  public var headers: [Swift.String : Swift.String]
  public func encode(to encoder: Swift.Encoder) throws
}
open class Component<DependencyType> : Treasure.Dependency {
  final public let dependency: DependencyType
  public init(dependency: DependencyType)
  final public func shared<T>(__function: Swift.String = #function, _ factory: () -> T) -> T
  @objc deinit
}
open class EmptyComponent : Treasure.EmptyDependency {
  public init()
  @objc deinit
}
public struct FetchContextResponse : Treasure.TreasureAPIResponse {
  public let context: Treasure.Context
  public init(from decoder: Swift.Decoder) throws
}
public enum TreasureActionType : Swift.String {
  case sendRequest
  case external
  case sdk
  case setContext
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AnyTreasureAction : Swift.Decodable {
  case navigate(Treasure.NavigateAction)
  case sendRequest(Treasure.SendRequestAction)
  case external(Treasure.ExternalAction)
  case sdk(Treasure.ElementsSDKAction)
  case setContext(Treasure.SetContextAction)
  case none
  public init(from decoder: Swift.Decoder) throws
  public var value: Treasure.TreasureAction? {
    get
  }
}
public struct UnsupportedActionDecoder {
}
public struct NavigateActionDecoder {
}
public struct SendRequestActionDecoder {
}
public struct ExternalActionDecoder {
}
public struct SDKActionDecoder {
}
public struct SetContextActionDecoder {
}
public enum AnyTreasureActionDecoder {
}
public enum SectionRenderModeling {
  case section(Treasure.SectionModel)
  case bars([Treasure.BarModeling])
  public var toSectionModel: Treasure.SectionModel? {
    get
  }
  public var toBarsModel: [Treasure.BarModeling]? {
    get
  }
}
public struct SectionBuilderIngredients<T> where T : Treasure.TreasureSection {
  public let value: T
  public let sectionID: Swift.String?
  public let renderType: Treasure.TreasureSectionRenderType
}
public protocol TreasureUISectionBuilder {
  func build(ingredients: Treasure.SectionBuilderIngredients<Treasure.GeneralListContentSection>) -> Treasure.SectionRenderModeling?
}
@objc @_Concurrency.MainActor(unsafe) final public class HGroup : UIKit.UILayoutGuide, Treasure.Constrainable {
  @_Concurrency.MainActor(unsafe) public init(style: Treasure.HGroup.Style = .init(), items: [Treasure.GroupItemModeling] = [])
  @_Concurrency.MainActor(unsafe) convenience public init(alignment: Treasure.HGroup.ItemAlignment = .fill, accessibilityAlignment: Treasure.VGroup.ItemAlignment = .leading, spacing: CoreGraphics.CGFloat = 0, items: [Treasure.GroupItemModeling] = [])
  @_Concurrency.MainActor(unsafe) convenience public init(style: Treasure.HGroup.Style = .init(), @Treasure.GroupModelBuilder _ content: () -> [Treasure.GroupItemModeling])
  @_Concurrency.MainActor(unsafe) convenience public init(alignment: Treasure.HGroup.ItemAlignment = .fill, accessibilityAlignment: Treasure.VGroup.ItemAlignment = .leading, spacing: CoreGraphics.CGFloat = 0, @Treasure.GroupModelBuilder _ content: () -> [Treasure.GroupItemModeling])
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  public struct Style : Swift.Hashable {
    public init(alignment: Treasure.HGroup.ItemAlignment = .fill, accessibilityAlignment: Treasure.VGroup.ItemAlignment = .leading, spacing: CoreGraphics.CGFloat = 0, reflowsForAccessibilityTypeSizes: Swift.Bool = true, forceVerticalAccessibilityLayout: Swift.Bool = false)
    public static func == (a: Treasure.HGroup.Style, b: Treasure.HGroup.Style) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) final public let alignment: Treasure.HGroup.ItemAlignment
  @_Concurrency.MainActor(unsafe) final public let accessibilityAlignment: Treasure.VGroup.ItemAlignment
  @_Concurrency.MainActor(unsafe) final public var items: [Treasure.AnyGroupItem] {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var reflowsForAccessibilityTypeSizes: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var forceVerticalAccessibilityLayout: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var spacing: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var firstBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var lastBaselineAnchor: UIKit.NSLayoutYAxisAnchor {
    get
  }
  @_Concurrency.MainActor(unsafe) final public func reflowsForAccessibilityTypeSizes(_ reflow: Swift.Bool) -> Treasure.HGroup
  @_Concurrency.MainActor(unsafe) final public func forceAccessibilityVerticalLayout(_ forceIn: Swift.Bool) -> Treasure.HGroup
  @_Concurrency.MainActor(unsafe) final public func setItems(_ newItems: [Treasure.GroupItemModeling], animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) final public func setItems(@Treasure.GroupModelBuilder _ buildItems: () -> [Treasure.GroupItemModeling], animated: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) final public func constrainable(with dataID: Swift.AnyHashable) -> Treasure.Constrainable?
  @_Concurrency.MainActor(unsafe) final public func groupItem(with dataID: Swift.AnyHashable) -> Treasure.AnyGroupItem?
  @_Concurrency.MainActor(unsafe) final public func install(in view: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) final public func uninstall()
  @_Concurrency.MainActor(unsafe) final public func isEqual(to constrainable: Treasure.Constrainable) -> Swift.Bool
  @objc deinit
}
public struct SpacerItem {
  public init(dataID: Swift.AnyHashable, style: Treasure.Spacer.Style = .init())
  public var dataID: Swift.AnyHashable
  public var style: Treasure.Spacer.Style
}
extension Treasure.SpacerItem : Treasure.GroupItemModeling {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func eraseToAnyGroupItem() -> Treasure.AnyGroupItem
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
public struct TreasureScope<Base> {
  public let base: Base
  public init(base: Base)
}
public protocol TreasureCompatible {
  associatedtype BlocksBase
  var blocks: Treasure.TreasureScope<Self.BlocksBase> { get }
}
extension Treasure.TreasureCompatible {
  public var blocks: Treasure.TreasureScope<Self> {
    get
  }
}
public protocol MakeViewProviding {
  associatedtype View : UIKit.UIView
  typealias MakeView = () -> Self.View
  var makeView: Self.MakeView { get }
}
extension Treasure.ViewEpoxyModeled where Self : Treasure.MakeViewProviding {
  public var makeView: Self.MakeView {
    get
    set
  }
  public func makeView(_ value: @escaping Self.MakeView) -> Self
}
public enum ItemSelectionStyle : Swift.Hashable {
  case noBackground
  case color(UIKit.UIColor)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Treasure.ItemSelectionStyle, b: Treasure.ItemSelectionStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ContentConfigurableView : UIKit.UIView {
  associatedtype Content : Swift.Equatable = Swift.Never
  func setContent(_ content: Self.Content, animated: Swift.Bool)
}
extension Treasure.ContentConfigurableView where Self.Content == Swift.Never {
  public func setContent(_ content: Swift.Never, animated: Swift.Bool)
}
public protocol FittingPrioritiesProvidingLayoutAttributes : UIKit.UICollectionViewLayoutAttributes {
  var horizontalFittingPriority: UIKit.UILayoutPriority { get }
  var verticalFittingPriority: UIKit.UILayoutPriority { get }
}
public protocol GroupItemsProviding {
  var groupItems: [Treasure.GroupItemModeling] { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.GroupItemsProviding {
  public var groupItems: [Treasure.GroupItemModeling] {
    get
    set
  }
  public func groupItems(_ value: [Treasure.GroupItemModeling]) -> Self
}
public enum TextLabelAlignment : Swift.String, Swift.Codable {
  case leading
  case center
  case trailing
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct LabelElementStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public let textColor: Treasure.ColorSource?
  public let textFont: Treasure.FontSource?
  public let alignment: Treasure.TextLabelAlignment?
  public let numberOfLines: Swift.Int?
  public init(id: Swift.String, basicProps: Treasure.ElementStyleProps? = nil, textColor: Treasure.ColorSource? = nil, textFont: Treasure.FontSource? = nil, alignment: Treasure.TextLabelAlignment? = nil, numberOfLines: Swift.Int? = nil)
  public init(from decoder: Swift.Decoder) throws
}
public struct LabelElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let title: Treasure.Expression<Swift.String>
  public let style: Treasure.Expression<Swift.String>?
  public init(id: Swift.String, title: Treasure.Expression<Swift.String>, style: Treasure.Expression<Swift.String>? = nil)
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
final public class ActivityData {
  public init(size: CoreGraphics.CGSize? = nil, message: Swift.String? = nil, messageFont: UIKit.UIFont? = nil, messageSpacing: CoreGraphics.CGFloat? = nil, type: Treasure.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreGraphics.CGFloat? = nil, displayTimeThreshold: Swift.Int? = nil, minimumDisplayTime: Swift.Int? = nil, backgroundColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class NVActivityIndicatorPresenter {
  public static let sharedInstance: Treasure.NVActivityIndicatorPresenter
  final public var isAnimating: Swift.Bool {
    get
  }
  final public func startAnimating(_ data: Treasure.ActivityData, _ fadeInAnimation: Treasure.FadeInAnimation?)
  final public func stopAnimating(_ fadeOutAnimation: Treasure.FadeOutAnimation?)
  final public func setMessage(_ message: Swift.String?)
  @objc deinit
}
public enum NavigationStyle {
  case none
  case withNavigation
  public static func == (a: Treasure.NavigationStyle, b: Treasure.NavigationStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PopoverConfig {
  public enum Source {
    case barButtonItem(UIKit.UIBarButtonItem)
    case view(container: UIKit.UIView, frame: CoreGraphics.CGRect?)
  }
  public init(source: Treasure.PopoverConfig.Source, arrowDirection: UIKit.UIPopoverArrowDirection = .any, delegate: UIKit.UIPopoverPresentationControllerDelegate? = nil)
}
public enum PresentationType {
  case modal(Treasure.NavigationStyle, UIKit.UIModalPresentationStyle, UIKit.UIModalTransitionStyle)
  case popover(Treasure.PopoverConfig)
  case push
  case show
  case showDetail(Treasure.NavigationStyle)
  case custom(UIKit.UIViewControllerTransitioningDelegate)
  case none
}
public protocol HorizontalAlignmentProviding {
  var horizontalAlignment: Treasure.VGroup.ItemAlignment? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.HorizontalAlignmentProviding {
  public var horizontalAlignment: Treasure.VGroup.ItemAlignment? {
    get
    set
  }
  public func horizontalAlignment(_ value: Treasure.VGroup.ItemAlignment?) -> Self
}
public protocol ViewEpoxyModeled : Treasure.EpoxyModeled {
  associatedtype View : UIKit.UIView
}
public protocol DidChangeStateProviding {
}
extension Treasure.CallbackContextEpoxyModeled where Self : Treasure.DidChangeStateProviding {
  public typealias DidChangeState = (Self.CallbackContext) -> Swift.Void
  public var didChangeState: Self.DidChangeState? {
    get
    set
  }
  public func didChangeState(_ value: Self.DidChangeState?) -> Self
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class BarWrapperView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var model: Treasure.BarModeling? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var coordinator: Treasure.AnyBarCoordinating? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var view: UIKit.UIView? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public func setModel(_ model: Treasure.BarModeling?, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func hitTest(_ point: CoreGraphics.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutMarginsDidChange()
  @objc deinit
}
public protocol UIAnimator {
  var defaultDuration: Foundation.TimeInterval { get }
}
extension Treasure.UIAnimator {
  public var defaultDuration: Foundation.TimeInterval {
    get
  }
}
@_hasMissingDesignatedInitializers public class DefaultAnimator : Treasure.UIAnimator {
  public static let duration: Swift.Double
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class UpdateConstraintsAnimator : Treasure.UIAnimator {
  final public func updateConstraints(containerView: UIKit.UIView)
  final public func updateConstraints(containerView: UIKit.UIView, completion: ((Swift.Bool) -> Swift.Void)?)
  final public func updateConstraints(containerView: UIKit.UIView, duration: Foundation.TimeInterval)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class BounceAnimator : Treasure.UIAnimator {
  final public func bounce(containerView: UIKit.UIView, delay: Swift.Double = 0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FadeInOutViewAnimator : Treasure.UIAnimator {
  public static let defaultBorderWidthAnimKey: Swift.String
  final public func animateToDisplay(view: UIKit.UIView, duration: Foundation.TimeInterval, completion: ((Swift.Bool) -> Swift.Void)?)
  final public func animateToDismiss(view: UIKit.UIView, duration: Foundation.TimeInterval, completion: ((Swift.Bool) -> Swift.Void)?)
  final public func fadeTransition(view: UIKit.UIView, _ duration: CoreFoundation.CFTimeInterval)
  final public func fadeViewBorder(view: UIKit.UIView, from: CoreGraphics.CGFloat, to: CoreGraphics.CGFloat, duration: CoreFoundation.CFTimeInterval)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SlideMenuAnimator : Treasure.UIAnimator {
  final public func animateToDisplay(view: UIKit.UIView, finalFrame: CoreGraphics.CGRect, duration: Foundation.TimeInterval, completion: ((Swift.Bool) -> Swift.Void)?)
  final public func animateToDismiss(view: UIKit.UIView, duration: Foundation.TimeInterval, completion: ((Swift.Bool) -> Swift.Void)?)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ShakeAnimator : Treasure.UIAnimator {
  public static let defaultShakeAnimKey: Swift.String
  final public func shake(view: UIKit.UIView)
  @objc deinit
}
final public class RotationAnimatior : Treasure.UIAnimator {
  public static let defaultRotationKey: Swift.String
  final public func animateRotation(view: UIKit.UIView, animationKey: Swift.String = RotationAnimatior.defaultRotationKey, repeatCount: Swift.Float = .infinity, delayForRound: Foundation.TimeInterval = 0.2, durationForRound: Foundation.TimeInterval = 2.2)
  public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class PopMessageAnimator : Treasure.UIAnimator {
  final public func animateForOpening(view: UIKit.UIView, startingScale: CoreGraphics.CGFloat = 0.3, duration: Foundation.TimeInterval = 0.7, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  final public func animateForEnding(view: UIKit.UIView, startingScale: CoreGraphics.CGFloat = 1, finalScale: CoreGraphics.CGFloat = 0.3, duration: Foundation.TimeInterval = 0.7, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc deinit
}
public protocol InternalBarCoordinating : Treasure.Diffable, Treasure.EpoxyModeled {
  func makeCoordinator(update: @escaping (_ animated: Swift.Bool) -> Swift.Void) -> Treasure.AnyBarCoordinating
  func barModel(for coordinator: Treasure.AnyBarCoordinating) -> Treasure.BarModeling
  func canReuseCoordinator(_ coordinator: Treasure.AnyBarCoordinating) -> Swift.Bool
}
public enum TreasureRoute : Swift.Decodable {
  public struct NewPath : Swift.Decodable {
    public struct HttpAdditionalData : Swift.Decodable {
      public init(from decoder: Swift.Decoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
  }
  case remote(Treasure.TreasureRoute.NewPath)
  case screen(Swift.String)
  case localFile(name: Swift.String)
}
extension Treasure.TreasureRoute {
  public init(from decoder: Swift.Decoder) throws
}
public protocol DidEndDisplayingProviding {
}
extension Treasure.CallbackContextEpoxyModeled where Self : Treasure.DidEndDisplayingProviding {
  public typealias DidEndDisplaying = ((_ context: Self.CallbackContext) -> Swift.Void)
  public var didEndDisplaying: Self.DidEndDisplaying? {
    get
    set
  }
  public func didEndDisplaying(_ value: Self.DidEndDisplaying?) -> Self
}
extension Foundation.URLSession : Treasure.TreasureCompatible {
  public typealias BlocksBase = Foundation.URLSession
}
public enum ColorSource : Swift.Decodable {
  case designSystem(Swift.String)
  case hex(Swift.String)
  public init(from decoder: Swift.Decoder) throws
}
public protocol AccessibilityCustomizedView : UIKit.UIView {
}
public enum HttpMethod : Swift.String, Swift.Codable {
  case get
  case post
  case put
  case delete
  case head
  case patch
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol TreasureAPIRequest : Swift.Encodable {
  associatedtype ResponseType : Treasure.TreasureAPIResponse
  var path: Swift.String { get }
  var counter: Swift.UInt { get set }
  var headers: [Swift.String : Swift.String] { get }
  var queryParameters: [Foundation.URLQueryItem] { get }
  var method: Treasure.HttpMethod { get }
}
public protocol TreasureAPIResponse : Swift.Decodable {
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class HGroupView : UIKit.UIView, Treasure.EpoxyableView {
  @_Concurrency.MainActor(unsafe) public init(style: Treasure.HGroupView.Style)
  public struct Style : Swift.Hashable {
    public init(hGroupStyle: Treasure.HGroup.Style = .init(), edgeInsets: Treasure.GroupEdgeInsets = .zero)
    public var hGroupStyle: Treasure.HGroup.Style
    public var edgeInsets: Treasure.GroupEdgeInsets
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Treasure.HGroupView.Style, b: Treasure.HGroupView.Style) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Content : Swift.Equatable {
    public init(items: [Treasure.GroupItemModeling])
    public init(@Treasure.GroupModelBuilder _ itemBuilder: () -> [Treasure.GroupItemModeling])
    public var items: [Treasure.AnyGroupItem]
    public static func == (lhs: Treasure.HGroupView.Content, rhs: Treasure.HGroupView.Content) -> Swift.Bool
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @_Concurrency.MainActor(unsafe) final public func setContent(_ content: Treasure.HGroupView.Content, animated: Swift.Bool)
  public typealias Behaviors = Swift.Never
  @objc deinit
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView {
  public static func groupItem(dataID: Swift.AnyHashable, content: Self.Content, behaviors: Self.Behaviors? = nil, style: Self.Style) -> Treasure.GroupItem<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Style == Swift.Never {
  public static func groupItem(dataID: Swift.AnyHashable, content: Self.Content, behaviors: Self.Behaviors? = nil) -> Treasure.GroupItem<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Content == Swift.Never {
  public static func groupItem(dataID: Swift.AnyHashable, behaviors: Self.Behaviors? = nil, style: Self.Style) -> Treasure.GroupItem<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Content == Swift.Never, Self.Style == Swift.Never {
  public static func groupItem(dataID: Swift.AnyHashable, behaviors: Self.Behaviors? = nil) -> Treasure.GroupItem<Self>
}
public struct BarModel<View> : Treasure.ViewEpoxyModeled where View : UIKit.UIView {
  public init(dataID: Swift.AnyHashable? = nil)
  public init<Content>(dataID: Swift.AnyHashable? = nil, content: Content, setContent: @escaping (Treasure.BarModel<View>.CallbackContext, Content) -> Swift.Void) where Content : Swift.Equatable
  public init<Params, Content>(dataID: Swift.AnyHashable? = nil, params: Params, content: Content, makeView: @escaping (Params) -> View, setContent: @escaping (Treasure.BarModel<View>.CallbackContext, Content) -> Swift.Void) where Params : Swift.Hashable, Content : Swift.Equatable
  public var storage: Treasure.EpoxyModelStorage
  public func makeCoordinator<Coordinator>(_ makeCoordinator: @escaping (_ update: @escaping (_ animated: Swift.Bool) -> Swift.Void) -> Coordinator) -> Treasure.BarModel<View> where Coordinator : Treasure.BarCoordinating, Coordinator.Model == Treasure.BarModel<View>
}
extension Treasure.BarModel : Treasure.SetContentProviding {
}
extension Treasure.BarModel : Treasure.ErasedContentProviding {
}
extension Treasure.BarModel : Treasure.DataIDProviding {
}
extension Treasure.BarModel : Treasure.DidDisplayProviding {
}
extension Treasure.BarModel : Treasure.MakeViewProviding {
}
extension Treasure.BarModel : Treasure.SetBehaviorsProviding {
}
extension Treasure.BarModel : Treasure.StyleIDProviding {
}
extension Treasure.BarModel : Treasure.WillDisplayProviding {
}
extension Treasure.BarModel : Treasure.DidSelectProviding {
}
extension Treasure.BarModel : Treasure.BarModeling {
  public func eraseToAnyBarModel() -> Treasure.AnyBarModel
}
extension Treasure.BarModel : Treasure.InternalBarCoordinating {
  public func barModel(for coordinator: Treasure.AnyBarCoordinating) -> Treasure.BarModeling
  public func makeCoordinator(update: @escaping (Swift.Bool) -> Swift.Void) -> Treasure.AnyBarCoordinating
  public func canReuseCoordinator(_ coordinator: Treasure.AnyBarCoordinating) -> Swift.Bool
}
extension Treasure.BarModel : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension Treasure.BarModel : Treasure.CallbackContextEpoxyModeled {
  public struct CallbackContext : Treasure.ViewProviding, Treasure.TraitCollectionProviding, Treasure.AnimatedProviding {
    public init(view: Treasure.BarModel<View>.CallbackContext.View, traitCollection: UIKit.UITraitCollection, animated: Swift.Bool)
    public var view: View
    public var traitCollection: UIKit.UITraitCollection
    public var animated: Swift.Bool
  }
}
public protocol IsMovableProviding {
  var isMovable: Swift.Bool { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.IsMovableProviding {
  public var isMovable: Swift.Bool {
    get
    set
  }
  public func isMovable(_ value: Swift.Bool) -> Self
}
extension CoreGraphics.CGSize : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension UIKit.UIEdgeInsets : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias BarModelBuilder = Treasure.EpoxyModelArrayBuilder<Treasure.BarModeling>
public struct BarCoordinatorProperty<Property> {
  public init<Coordinator>(keyPath: Swift.ReferenceWritableKeyPath<Coordinator, Property>, default: @autoclosure @escaping () -> Property, function: Swift.String = #function)
  public let keyPath: Swift.AnyKeyPath
  public let function: Swift.String
  public let `default`: () -> Property
}
public protocol BarCoordinatorPropertyConfigurable : AnyObject {
  var coordinators: [Treasure.AnyBarCoordinating] { get }
  subscript<Property>(property: Treasure.BarCoordinatorProperty<Property>) -> Property { get set }
  func observe<Property>(_ property: Treasure.BarCoordinatorProperty<Property>, observer: @escaping (Property) -> Swift.Void) -> Swift.AnyObject
}
public struct PresentationModel {
  public init(dataID: Swift.AnyHashable, presentation: Treasure.PresentationModel.Presentation, makeViewController: @escaping () -> UIKit.UIViewController?, dismiss: @escaping () -> Swift.Void)
  public init<Params>(params: Params, dataID: Swift.AnyHashable, presentation: Treasure.PresentationModel.Presentation, makeViewController: @escaping (Params) -> UIKit.UIViewController?, dismiss: @escaping () -> Swift.Void) where Params : Swift.Equatable
  public func didPresent(_ didPresent: @escaping (() -> Swift.Void)) -> Treasure.PresentationModel
  public func didDismiss(_ didDismiss: @escaping (() -> Swift.Void)) -> Treasure.PresentationModel
}
extension Treasure.PresentationModel : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension Treasure.PresentationModel {
  public init(dataID: Swift.AnyHashable, makePresentable: @escaping () -> Treasure.PresentationModel.Presentable?, dismiss: @escaping () -> Swift.Void)
  public init<Params>(params: Params, dataID: Swift.AnyHashable, makePresentable: @escaping (Params) -> Treasure.PresentationModel.Presentable?, dismiss: @escaping () -> Swift.Void) where Params : Swift.Equatable
}
extension Treasure.PresentationModel {
  public struct Presentation {
    public init(present: @escaping (_ presented: UIKit.UIViewController) -> Treasure.PresentationModel.Presentable)
    public struct Context {
      public var presenting: UIKit.UIViewController
      public var animated: Swift.Bool
      public var didPresent: () -> Swift.Void
      public var didDismiss: () -> Swift.Void
    }
    public var present: (_ presented: UIKit.UIViewController) -> Treasure.PresentationModel.Presentable
  }
  public typealias Presentable = (_ context: Treasure.PresentationModel.Presentation.Context) -> Treasure.PresentationModel.Dismissible
  public typealias Dismissible = (_ animated: Swift.Bool, _ completion: (() -> Swift.Void)?) -> Swift.Void
}
extension Treasure.PresentationModel.Presentation {
  public static var system: Treasure.PresentationModel.Presentation {
    get
  }
  public static func customized(transitionDelegate: UIKit.UIViewControllerTransitioningDelegate) -> Treasure.PresentationModel.Presentation
}
public enum CollectionSectionItemLayoutSizeType : Swift.String, Swift.Decodable {
  case fractional
  case absolute
  case estimated
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum TreasureLayoutOrthogonalScrollingType : Swift.String, Swift.Decodable {
  case none
  case continuous
  case continuousGroupLeadingBoundary
  case paging
  case groupPaging
  case groupPagingCentered
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CollectionSectionItemLayoutSize : Swift.Decodable {
  case fractional(percentage: Swift.Double)
  case absolute(size: Swift.Double)
  case estimated(size: Swift.Double)
  public init(from decoder: Swift.Decoder) throws
}
public enum TreasureSectionLayoutType : Swift.String, Swift.Decodable {
  case list
  case carousel
  case carouselWithHeader
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct TreasureSectionLayoutData : Swift.Decodable {
  public let type: Treasure.TreasureSectionLayoutType
  public let itemWidth: Treasure.CollectionSectionItemLayoutSize?
  public let itemHeight: Treasure.CollectionSectionItemLayoutSize?
  public let sectionInsets: Treasure.LayoutMargins?
  public let scrollType: Treasure.TreasureLayoutOrthogonalScrollingType?
  public init(from decoder: Swift.Decoder) throws
}
extension Swift.Collection where Self.Element : Treasure.Diffable, Self.Index == Swift.Int {
  public func makeChangeset(from other: Self) -> Treasure.IndexChangeset
  public func makeIndexPathChangeset(from other: Self, fromSection: Swift.Int = 0, toSection: Swift.Int = 0) -> Treasure.IndexPathChangeset
  public func makeIndexSetChangeset(from other: Self) -> Treasure.IndexSetChangeset
}
extension Swift.Collection where Self.Element : Treasure.DiffableSection, Self.Index == Swift.Int {
  public func makeSectionedChangeset(from other: Self) -> Treasure.SectionedChangeset
}
public protocol EpoxyCollectionViewDelegateFlowLayout {
  func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemWith dataID: Swift.AnyHashable, inSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGSize
  func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, insetForSectionWith sectionDataID: Swift.AnyHashable) -> UIKit.UIEdgeInsets
  func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumLineSpacingForSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGFloat
  func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumInteritemSpacingForSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGFloat
  func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, referenceSizeForHeaderInSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGSize
  func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, referenceSizeForFooterInSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGSize
}
extension Treasure.EpoxyCollectionViewDelegateFlowLayout {
  public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemWith dataID: Swift.AnyHashable, inSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGSize
  public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, insetForSectionWith sectionDataID: Swift.AnyHashable) -> UIKit.UIEdgeInsets
  public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumLineSpacingForSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGFloat
  public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumInteritemSpacingForSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGFloat
  public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, referenceSizeForHeaderInSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGSize
  public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, referenceSizeForFooterInSectionWith sectionDataID: Swift.AnyHashable) -> CoreGraphics.CGSize
}
extension Treasure.CollectionView : UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGSize
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, insetForSectionAt section: Swift.Int) -> UIKit.UIEdgeInsets
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumLineSpacingForSectionAt section: Swift.Int) -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Swift.Int) -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, referenceSizeForHeaderInSection section: Swift.Int) -> CoreGraphics.CGSize
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, referenceSizeForFooterInSection section: Swift.Int) -> CoreGraphics.CGSize
}
extension UIKit.UIColor {
  convenience public init?(red: Swift.Int, green: Swift.Int, blue: Swift.Int, transparency: CoreGraphics.CGFloat = 1)
  convenience public init?(hex: Swift.Int, transparency: CoreGraphics.CGFloat = 1)
  convenience public init?(hexString: Swift.String?)
}
public struct EpoxyModelProperty<Value> {
  public init<Model>(keyPath: Swift.KeyPath<Model, Value>, defaultValue: @autoclosure @escaping () -> Value, updateStrategy: Treasure.EpoxyModelProperty<Value>.UpdateStrategy)
  public let keyPath: Swift.AnyKeyPath
  public let defaultValue: () -> Value
  public let updateStrategy: Treasure.EpoxyModelProperty<Value>.UpdateStrategy
}
extension Treasure.EpoxyModelProperty {
  public struct UpdateStrategy {
    public init(update: @escaping (Value, Value) -> Value)
    public var update: (_ old: Value, _ new: Value) -> Value
  }
}
extension Treasure.EpoxyModelProperty.UpdateStrategy {
  public static var replace: Treasure.EpoxyModelProperty<Value>.UpdateStrategy {
    get
  }
  public static func chain() -> Treasure.EpoxyModelProperty<(() -> Swift.Void)?>.UpdateStrategy
  public static func chain<A>() -> Treasure.EpoxyModelProperty<((A) -> Swift.Void)?>.UpdateStrategy
  public static func chain<A, B>() -> Treasure.EpoxyModelProperty<((A, B) -> Swift.Void)?>.UpdateStrategy
  public static func chain<A, B, C>() -> Treasure.EpoxyModelProperty<((A, B, C) -> Swift.Void)?>.UpdateStrategy
  public static func chain<A, B, C, D>() -> Treasure.EpoxyModelProperty<((A, B, C, D) -> Swift.Void)?>.UpdateStrategy
}
public struct IndexChangeset {
  public init(inserts: [Swift.Int] = [], deletes: [Swift.Int] = [], updates: [(old: Swift.Int, new: Swift.Int)] = [], moves: [(old: Swift.Int, new: Swift.Int)] = [], newIndices: [Swift.Int?] = [], duplicates: [[Swift.Int]] = [])
  public var inserts: [Swift.Int]
  public var deletes: [Swift.Int]
  public var updates: [(old: Swift.Int, new: Swift.Int)]
  public var moves: [(old: Swift.Int, new: Swift.Int)]
  public var newIndices: [Swift.Int?]
  public var duplicates: [[Swift.Int]]
  public var isEmpty: Swift.Bool {
    get
  }
}
public struct IndexPathChangeset {
  public init(inserts: [Foundation.IndexPath] = [], deletes: [Foundation.IndexPath] = [], updates: [(old: Foundation.IndexPath, new: Foundation.IndexPath)] = [], moves: [(old: Foundation.IndexPath, new: Foundation.IndexPath)] = [], duplicates: [[Foundation.IndexPath]] = [])
  public var inserts: [Foundation.IndexPath]
  public var deletes: [Foundation.IndexPath]
  public var updates: [(old: Foundation.IndexPath, new: Foundation.IndexPath)]
  public var moves: [(old: Foundation.IndexPath, new: Foundation.IndexPath)]
  public var duplicates: [[Foundation.IndexPath]]
  public var isEmpty: Swift.Bool {
    get
  }
  public static func += (left: inout Treasure.IndexPathChangeset, right: Treasure.IndexPathChangeset)
}
public struct IndexSetChangeset {
  public init(inserts: Foundation.IndexSet = [], deletes: Foundation.IndexSet = [], updates: [(old: Swift.Int, new: Swift.Int)] = [], moves: [(old: Swift.Int, new: Swift.Int)] = [], newIndices: [Swift.Int?] = [], duplicates: [Foundation.IndexSet] = [])
  public var inserts: Foundation.IndexSet
  public var deletes: Foundation.IndexSet
  public var updates: [(old: Swift.Int, new: Swift.Int)]
  public var moves: [(old: Swift.Int, new: Swift.Int)]
  public var newIndices: [Swift.Int?]
  public var duplicates: [Foundation.IndexSet]
  public var isEmpty: Swift.Bool {
    get
  }
}
public protocol AccessibilityAlignmentProviding {
  var accessibilityAlignment: Treasure.VGroup.ItemAlignment? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.AccessibilityAlignmentProviding {
  public var accessibilityAlignment: Treasure.VGroup.ItemAlignment? {
    get
    set
  }
  public func accessibilityAlignment(_ value: Treasure.VGroup.ItemAlignment?) -> Self
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FullScreenPresentableView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) open func show()
  @_Concurrency.MainActor(unsafe) open func animateForOpening()
  @_Concurrency.MainActor(unsafe) open func hide(duration: Foundation.TimeInterval = 0.15, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) open func cleanViews()
  @_Concurrency.MainActor(unsafe) open func setupUI()
  @_Concurrency.MainActor(unsafe) open func configureConstraints(_: UIKit.UIView)
  @objc deinit
}
public enum TreasureImageType : Swift.String, Swift.Decodable {
  case localImage
  case imageURL
  case lottieURL
  case localLottie
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum TreasureImageSource : Swift.Decodable {
  case staticImage(image: UIKit.UIImage)
  case imageURL(url: Foundation.URL)
  case lottieAnimationImage(url: Foundation.URL)
  case lottieAnimation(named: Swift.String)
  public init?(imageURL: Foundation.URL?)
  public init(from decoder: Swift.Decoder) throws
  public var getPotentialDownloadURL: Foundation.URL? {
    get
  }
  public var getPotentialStaticImage: UIKit.UIImage? {
    get
  }
}
public protocol StyleIDProviding {
  var styleID: Swift.AnyHashable? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.StyleIDProviding {
  public var styleID: Swift.AnyHashable? {
    get
    set
  }
  public func styleID(_ value: Swift.AnyHashable?) -> Self
}
public protocol DidSelectProviding {
}
extension Treasure.CallbackContextEpoxyModeled where Self : Treasure.DidSelectProviding {
  public typealias DidSelect = ((Self.CallbackContext) -> Swift.Void)
  public var didSelect: Self.DidSelect? {
    get
    set
  }
  public func didSelect(_ value: Self.DidSelect?) -> Self
}
public protocol SelectionStyleProviding {
  var selectionStyle: Treasure.ItemSelectionStyle? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.SelectionStyleProviding {
  public var selectionStyle: Treasure.ItemSelectionStyle? {
    get
    set
  }
  public func selectionStyle(_ value: Treasure.ItemSelectionStyle?) -> Self
}
@objc @_Concurrency.MainActor(unsafe) final public class InputAccessoryBarStackView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public init(bars: [Treasure.BarModeling] = [])
  @_Concurrency.MainActor(unsafe) convenience public init(@Treasure.BarModelBuilder bars: () -> [Treasure.BarModeling])
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) final public let barStack: Treasure.BarStackView
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreGraphics.CGSize {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func safeAreaInsetsDidChange()
  @_Concurrency.MainActor(unsafe) final public func setBars(_ bars: [Treasure.BarModeling], animated: Swift.Bool)
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) public class BarStackView : UIKit.UIStackView, Treasure.EpoxyableView {
  @objc required dynamic public init()
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder: Foundation.NSCoder)
  public enum ZOrder {
    case firstToLast
    case lastToFirst
    public static func == (a: Treasure.BarStackView.ZOrder, b: Treasure.BarStackView.ZOrder) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var models: [Treasure.AnyBarModel] {
    get
  }
  @_Concurrency.MainActor(unsafe) public var zOrder: Treasure.BarStackView.ZOrder {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var selectedBackgroundColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var primaryBar: UIKit.UIView? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var primaryCoordinator: Treasure.AnyBarCoordinating? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var coordinators: [Treasure.AnyBarCoordinating] {
    get
  }
  @_Concurrency.MainActor(unsafe) public var barViews: [UIKit.UIView] {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func hitTest(_ point: CoreGraphics.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) public func setBars(_ models: [Treasure.BarModeling], animated: Swift.Bool)
  public typealias Behaviors = Swift.Never
  public typealias Style = Swift.Never
  @objc deinit
}
extension Treasure.BarStackView {
  @_Concurrency.MainActor(unsafe) public func setContent(_ content: Treasure.BarStackView.Content, animated: Swift.Bool)
}
extension Treasure.BarStackView {
  public struct Content : Swift.Equatable {
    public init(models: [Treasure.BarModeling], selectedBackgroundColor: UIKit.UIColor? = nil, zOrder: Treasure.BarStackView.ZOrder = .firstToLast)
    public var models: [Treasure.BarModeling]
    public var selectedBackgroundColor: UIKit.UIColor?
    public var zOrder: Treasure.BarStackView.ZOrder
    public static func == (lhs: Treasure.BarStackView.Content, rhs: Treasure.BarStackView.Content) -> Swift.Bool
  }
}
public enum FileWatcher {
  public enum Error : Swift.Error {
    case notStarted
    case alreadyStarted
    case alreadyStopped
    case failedToStart(reason: Swift.String)
  }
  public enum RefreshResult {
    case noChanges
    case updated(data: Foundation.Data)
  }
  public typealias UpdateClosure = (Treasure.FileWatcher.RefreshResult) -> Swift.Void
}
public protocol FileWatcherProtocol {
  func start(closure: @escaping Treasure.FileWatcher.UpdateClosure) throws
  func stop() throws
}
public protocol EpoxyModeled {
  var storage: Treasure.EpoxyModelStorage { get set }
}
extension Treasure.EpoxyModeled {
  public subscript<Property>(property: Treasure.EpoxyModelProperty<Property>) -> Property {
    get
    set
  }
  public func copy<Value>(updating property: Treasure.EpoxyModelProperty<Value>, to value: Value) -> Self
  public func merging(_ other: Treasure.EpoxyModeled) -> Self
}
public protocol ErasedContentProviding {
  var erasedContent: Any? { get }
  var isErasedContentEqual: ((Self) -> Swift.Bool)? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.ErasedContentProviding {
  public var erasedContent: Any? {
    get
    set
  }
  public var isErasedContentEqual: ((Self) -> Swift.Bool)? {
    get
    set
  }
}
public struct TreasureActionParameters {
  public let handler: Treasure.TreasureActionHandler
  public let context: Treasure.Context?
  public func convertToIngredients<T>(action: T) -> Treasure.ActionHandlerIngredients<T> where T : Treasure.TreasureAction
}
public protocol TreasureAction : Swift.Decodable {
  var analytics: Treasure.TreasureAnalytics? { get }
  func executeAction(params: Treasure.TreasureActionParameters)
}
public protocol ItemModeling : Treasure.DataIDProviding, Treasure.Diffable, Treasure.ViewDifferentiatorProviding {
  func eraseToAnyItemModel() -> Treasure.AnyItemModel
}
public protocol InternalItemModeling : Treasure.EpoxyModeled, Treasure.IsMovableProviding, Treasure.ItemModeling, Treasure.SelectionStyleProviding {
  func configure(cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  func setBehavior(cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  func configureStateChange(in cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  func handleDidSelect(_ cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  func handleWillDisplay(_ cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  func handleDidEndDisplaying(_ cell: Treasure.ItemWrapperView, with metadata: Treasure.ItemCellMetadata)
  var isSelectable: Swift.Bool { get }
  func configuredView(traitCollection: UIKit.UITraitCollection) -> UIKit.UIView
}
public protocol CallbackContextEpoxyModeled : Treasure.EpoxyModeled {
  associatedtype CallbackContext
}
public protocol SetContentProviding {
}
extension Treasure.CallbackContextEpoxyModeled where Self : Treasure.SetContentProviding {
  public typealias SetContent = (Self.CallbackContext) -> Swift.Void
  public var setContent: Self.SetContent? {
    get
    set
  }
  public func setContent(_ value: Self.SetContent?) -> Self
}
@dynamicMemberLookup public struct GroupItem<ItemType> : Treasure.EpoxyModeled where ItemType : Treasure.Constrainable {
  public init(dataID: Swift.AnyHashable, make: @escaping () -> ItemType)
  public init<Content>(dataID: Swift.AnyHashable, content: Content, make: @escaping () -> ItemType, setContent: @escaping (Treasure.GroupItem<ItemType>.CallbackContext, Content) -> Swift.Void) where Content : Swift.Equatable
  public init<Params, Content>(dataID: Swift.AnyHashable, params: Params, content: Content, make: @escaping (Params) -> ItemType, setContent: @escaping (Treasure.GroupItem<ItemType>.CallbackContext, Content) -> Swift.Void) where Params : Swift.Hashable, Content : Swift.Equatable
  public var make: () -> ItemType
  public var storage: Treasure.EpoxyModelStorage
  public func set<Value>(_ keypath: Swift.ReferenceWritableKeyPath<ItemType, Value>, value: Value) -> Treasure.GroupItem<ItemType>
  public func set<Value>(_ keypath: Swift.ReferenceWritableKeyPath<ItemType, Value>, value: Value) -> Treasure.GroupItem<ItemType> where Value : Swift.Equatable
  public subscript<Value>(dynamicMember keypath: Swift.ReferenceWritableKeyPath<ItemType, Value>) -> ((_ value: Value) -> Treasure.GroupItem<ItemType>) {
    get
  }
  public subscript<Value>(dynamicMember keypath: Swift.ReferenceWritableKeyPath<ItemType, Value>) -> ((_ value: Value) -> Treasure.GroupItem<ItemType>) where Value : Swift.Equatable {
    get
  }
}
extension Treasure.GroupItem where ItemType : UIKit.UIView {
  public func contentCompressionResistancePriority(_ priority: UIKit.UILayoutPriority, for axis: UIKit.NSLayoutConstraint.Axis) -> Treasure.GroupItem<ItemType>
  public func contentHuggingPriority(_ priority: UIKit.UILayoutPriority, for axis: UIKit.NSLayoutConstraint.Axis) -> Treasure.GroupItem<ItemType>
}
extension Treasure.GroupItem : Treasure.AccessibilityAlignmentProviding {
}
extension Treasure.GroupItem : Treasure.DataIDProviding {
}
extension Treasure.GroupItem : Treasure.ErasedContentProviding {
}
extension Treasure.GroupItem : Treasure.HorizontalAlignmentProviding {
}
extension Treasure.GroupItem : Treasure.PaddingProviding {
}
extension Treasure.GroupItem : Treasure.SetBehaviorsProviding {
}
extension Treasure.GroupItem : Treasure.SetContentProviding {
}
extension Treasure.GroupItem : Treasure.StyleIDProviding {
}
extension Treasure.GroupItem : Treasure.VerticalAlignmentProviding {
}
extension Treasure.GroupItem : Treasure.CallbackContextEpoxyModeled {
  public struct CallbackContext {
    public let constrainable: ItemType
    public let animated: Swift.Bool
    public init(constrainable: ItemType, animated: Swift.Bool)
  }
}
extension Treasure.GroupItem : Treasure.GroupItemModeling {
  public func eraseToAnyGroupItem() -> Treasure.AnyGroupItem
}
extension Treasure.GroupItem {
  public func makeConstrainable() -> Treasure.Constrainable
  public func update(_ constrainable: Treasure.Constrainable, animated: Swift.Bool)
  public func setBehaviors(on constrainable: Treasure.Constrainable)
}
extension Treasure.GroupItem {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
public protocol ReflowsForAccessibilityTypeSizeProviding {
  var reflowsForAccessibilityTypeSizes: Swift.Bool { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.ReflowsForAccessibilityTypeSizeProviding {
  public var reflowsForAccessibilityTypeSizes: Swift.Bool {
    get
    set
  }
  public func reflowsForAccessibilityTypeSizes(_ value: Swift.Bool) -> Self
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView {
  public static func itemModel(dataID: Swift.AnyHashable, content: Self.Content, behaviors: Self.Behaviors? = nil, style: Self.Style) -> Treasure.ItemModel<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Style == Swift.Never {
  public static func itemModel(dataID: Swift.AnyHashable, content: Self.Content, behaviors: Self.Behaviors? = nil) -> Treasure.ItemModel<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Content == Swift.Never {
  public static func itemModel(dataID: Swift.AnyHashable, behaviors: Self.Behaviors? = nil, style: Self.Style) -> Treasure.ItemModel<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Content == Swift.Never, Self.Style == Swift.Never {
  public static func itemModel(dataID: Swift.AnyHashable, behaviors: Self.Behaviors? = nil) -> Treasure.ItemModel<Self>
}
public protocol BehaviorsConfigurableView : UIKit.UIView {
  associatedtype Behaviors = Swift.Never
  func setBehaviors(_ behaviors: Self.Behaviors?)
}
extension Treasure.BehaviorsConfigurableView where Self.Behaviors == Swift.Never {
  public func setBehaviors(_ behaviors: Swift.Never?)
}
public struct TreasureEnvironment : Treasure.APIEnvironment {
  public var baseURL: Foundation.URL
  public var headers: [Swift.String : Swift.String] {
    get
  }
  public var queryParameters: [Foundation.URLQueryItem]
  public let clientToken: Swift.String
  public static func sandbox(clientToken: Swift.String) -> Treasure.TreasureEnvironment
  public static func portForward(clientToken: Swift.String) -> Treasure.TreasureEnvironment
  public static func production(clientToken: Swift.String) -> Treasure.TreasureEnvironment
  public static let unknown: Treasure.TreasureEnvironment
  public init(baseURL: Foundation.URL? = nil, clientToken: Swift.String)
}
public struct ActionHandlerIngredients<T> where T : Treasure.TreasureAction {
  public let value: T
  public let context: Treasure.Context?
}
public protocol TreasureActionHandler : AnyObject {
  func handle(navigateAction: Treasure.ActionHandlerIngredients<Treasure.NavigateAction>)
  func handle(externalAction: Treasure.ActionHandlerIngredients<Treasure.ExternalAction>)
  func handle(sdkAction: Treasure.ActionHandlerIngredients<Treasure.ElementsSDKAction>)
  func handle(sendRequestAction: Treasure.ActionHandlerIngredients<Treasure.SendRequestAction>)
  func handle(setContextAction: Treasure.ActionHandlerIngredients<Treasure.SetContextAction>)
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView {
  public static func supplementaryItemModel(dataID: Swift.AnyHashable, content: Self.Content, behaviors: Self.Behaviors? = nil, style: Self.Style) -> Treasure.SupplementaryItemModel<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Style == Swift.Never {
  public static func supplementaryItemModel(dataID: Swift.AnyHashable, content: Self.Content, behaviors: Self.Behaviors? = nil) -> Treasure.SupplementaryItemModel<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Content == Swift.Never {
  public static func supplementaryItemModel(dataID: Swift.AnyHashable, behaviors: Self.Behaviors? = nil, style: Self.Style) -> Treasure.SupplementaryItemModel<Self>
}
extension Treasure.StyledView where Self : Treasure.BehaviorsConfigurableView, Self : Treasure.ContentConfigurableView, Self.Content == Swift.Never, Self.Style == Swift.Never {
  public static func supplementaryItemModel(dataID: Swift.AnyHashable, behaviors: Self.Behaviors? = nil) -> Treasure.SupplementaryItemModel<Self>
}
public struct ItemCellMetadata {
  public init(traitCollection: UIKit.UITraitCollection, state: Treasure.ItemCellState, animated: Swift.Bool)
  public var traitCollection: UIKit.UITraitCollection
  public var state: Treasure.ItemCellState
  public var animated: Swift.Bool
}
public protocol DataIDProviding {
  var dataID: Swift.AnyHashable { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.DataIDProviding {
  public var dataID: Swift.AnyHashable {
    get
    set
  }
  public func dataID(_ value: Swift.AnyHashable) -> Self
}
public enum DefaultDataID : Swift.Hashable, Swift.CustomDebugStringConvertible {
  case noneProvided
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: Treasure.DefaultDataID, b: Treasure.DefaultDataID) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol DisplayRespondingView : UIKit.UIView {
  func didDisplay(_ isDisplayed: Swift.Bool)
}
extension Treasure.CornerRadius : Swift.Equatable {
}
public func == (lhs: Treasure.CornerRadius, rhs: Treasure.CornerRadius) -> Swift.Bool
extension Treasure.TreasureImageSource : Swift.Equatable {
}
public func == (lhs: Treasure.TreasureImageSource, rhs: Treasure.TreasureImageSource) -> Swift.Bool
extension Treasure.FileWatcher {
  final public class Remote : Treasure.FileWatcherProtocol {
    public init(url: Foundation.URL, refreshInterval: Foundation.TimeInterval = 1)
    @objc deinit
    final public func start(closure: @escaping Treasure.FileWatcher.UpdateClosure) throws
    final public func stop() throws
    @objc final public func refresh() throws
  }
}
public enum Literal {
  case int(Swift.Int)
  case double(Swift.Double)
  case bool(Swift.Bool)
  case string(Swift.String)
  case null
}
extension Treasure.Literal : Treasure.RepresentableByParsableString {
  public static let parser: Treasure.Parser<Treasure.Literal>
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public struct ConstrainableContainer : Treasure.Constrainable, Treasure.AnchoringContainer, Treasure.EpoxyModeled {
  public init(_ constrainable: Treasure.Constrainable)
  public var constrainable: Treasure.Constrainable {
    get
  }
  public var storage: Treasure.EpoxyModelStorage
  public var owningView: UIKit.UIView? {
    get
  }
  public var layoutFrame: CoreGraphics.CGRect {
    get
  }
  public var wrapped: Treasure.Constrainable {
    get
  }
  public var anchor: Treasure.Constrainable {
    get
  }
  public var dataID: Swift.AnyHashable {
    get
  }
  public func install(in view: UIKit.UIView)
  public func uninstall()
  public func isEqual(to constrainable: Treasure.Constrainable) -> Swift.Bool
}
extension Treasure.ConstrainableContainer : Treasure.AccessibilityAlignmentProviding {
}
extension Treasure.ConstrainableContainer : Treasure.HorizontalAlignmentProviding {
}
extension Treasure.ConstrainableContainer : Treasure.PaddingProviding {
}
extension Treasure.ConstrainableContainer : Treasure.VerticalAlignmentProviding {
}
extension Treasure.Constrainable {
  public func horizontalAlignment(_ alignment: Treasure.VGroup.ItemAlignment?) -> Treasure.Constrainable
  public func verticalAlignment(_ alignment: Treasure.HGroup.ItemAlignment?) -> Treasure.Constrainable
  public func accessibilityAlignment(_ alignment: Treasure.VGroup.ItemAlignment?) -> Treasure.Constrainable
  public func padding(_ insets: UIKit.NSDirectionalEdgeInsets) -> Treasure.Constrainable
  public func padding(_ length: CoreGraphics.CGFloat) -> Treasure.Constrainable
}
public protocol ViewDifferentiatorProviding {
  var viewDifferentiator: Treasure.ViewDifferentiator { get }
}
public struct ViewDifferentiator : Swift.Hashable {
  public init(viewType: Swift.AnyClass, styleID: Swift.AnyHashable?)
  public var viewTypeDescription: Swift.String
  public var styleID: Swift.AnyHashable?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Treasure.ViewDifferentiator, b: Treasure.ViewDifferentiator) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol HeightInvalidatingBarView : UIKit.UIView {
  var heightInvalidationContext: Treasure.BarHeightInvalidationContext? { get set }
}
extension Treasure.HeightInvalidatingBarView {
  @nonobjc public var heightInvalidationContext: Treasure.BarHeightInvalidationContext? {
    get
    set
  }
}
extension Treasure.HeightInvalidatingBarView {
  public func prepareHeightBarHeightInvalidation()
  public func invalidateBarHeight()
}
public struct BarHeightInvalidationContext {
}
public protocol DependencyLogger {
  var logger: Treasure.TreasureLoggerType { get }
}
public protocol TreasureLoggerType {
  func log(_ log: Treasure.LogType)
}
public class TreasureLoggerProxy : Treasure.TreasureLoggerType {
  final public let logger: Treasure.TreasureLoggerType?
  public init(logger: Treasure.TreasureLoggerType?)
  public func log(_ log: Treasure.LogType)
  @objc deinit
}
public struct StaticGroupItem {
  public init(_ constrainable: Treasure.Constrainable)
  public var storage: Treasure.EpoxyModelStorage
}
extension Treasure.StaticGroupItem {
  public var dataID: Swift.AnyHashable {
    get
  }
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func eraseToAnyGroupItem() -> Treasure.AnyGroupItem
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension Treasure.StaticGroupItem : Treasure.AccessibilityAlignmentProviding {
}
extension Treasure.StaticGroupItem : Treasure.DataIDProviding {
}
extension Treasure.StaticGroupItem : Treasure.HorizontalAlignmentProviding {
}
extension Treasure.StaticGroupItem : Treasure.PaddingProviding {
}
extension Treasure.StaticGroupItem : Treasure.VerticalAlignmentProviding {
}
public enum TreasureSectionRenderType {
  case section
  case bars
  public static func == (a: Treasure.TreasureSectionRenderType, b: Treasure.TreasureSectionRenderType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TreasureSectionParameters {
  public var sectionId: Swift.String?
  public let renderType: Treasure.TreasureSectionRenderType
  public let builder: Treasure.TreasureUISectionBuilder
  public func convertToIngredients<T>(section: T) -> Treasure.SectionBuilderIngredients<T> where T : Treasure.TreasureSection
}
public protocol TreasureSection : Swift.Decodable {
  var id: Swift.String { get }
  func buildUISection(parameters: Treasure.TreasureSectionParameters) -> Treasure.SectionRenderModeling?
}
public enum AnyTreasureSection : Swift.Decodable {
  case generalListContent(Treasure.GeneralListContentSection)
  case none
  public init(from decoder: Swift.Decoder) throws
  public var value: Treasure.TreasureSection? {
    get
  }
}
public struct BlueprintElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let blueprintId: Swift.String
  public let context: Treasure.Context
  public let style: Treasure.Expression<Swift.String>?
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
public protocol PaddingProviding {
  var padding: UIKit.NSDirectionalEdgeInsets { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.PaddingProviding {
  public var padding: UIKit.NSDirectionalEdgeInsets {
    get
    set
  }
  public func padding(_ value: UIKit.NSDirectionalEdgeInsets) -> Self
  public func padding(_ value: CoreGraphics.CGFloat) -> Self
}
public protocol ViewProviding {
  associatedtype View : UIKit.UIView
  var view: Self.View { get }
}
public typealias VoidCompletion = (() -> Swift.Void)
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func toPresentable() -> UIKit.UIViewController
}
public struct SimpleScheduler : Treasure.Scheduler {
  public init(maximumCount: Swift.Int)
  public func schedule(_ currentCount: Swift.UInt, closure: @escaping () -> Swift.Void) -> Swift.Bool
}
public enum Value {
  case binding(Treasure.Binding)
  case literal(Treasure.Literal)
}
extension Treasure.Value : Treasure.RepresentableByParsableString {
  public static let parser: Treasure.Parser<Treasure.Value>
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public protocol BarContainer : Treasure.BarStackView {
  var coordinators: [Treasure.AnyBarCoordinating] { get }
  var viewController: UIKit.UIViewController? { get set }
  func add(to superview: UIKit.UIView)
  func remove()
  var insetBehavior: Treasure.BarContainerInsetBehavior { get set }
}
public enum BarContainerInsetBehavior : Swift.Equatable {
  case barHeightSafeArea
  case barHeightContentInset
  case none
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Treasure.BarContainerInsetBehavior, b: Treasure.BarContainerInsetBehavior) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct TitleSubtitleElementStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public let verticalSpacing: Swift.Double?
  public let alignment: Treasure.TextLabelAlignment?
  public let titleStyleId: Swift.String
  public let subtitleStyleId: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public struct BasicListItemElementStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public let imageStyleId: Swift.String?
  public let trailingImageStyleId: Swift.String?
  public let titleSubtitleStyleId: Swift.String?
  public let hGroupAlignment: Treasure.HGroupContentAlignment?
  public let hSpacing: Swift.Double?
  public init(from decoder: Swift.Decoder) throws
}
public struct BasicListItemElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let style: Treasure.Expression<Swift.String>?
  public let title: Treasure.Expression<Swift.String>
  public let image: Treasure.Expression<Treasure.TreasureImageSource>?
  public let trailingImage: Treasure.Expression<Treasure.TreasureImageSource>?
  public let subtitle: Treasure.Expression<Swift.String>?
  public let onPressAction: Treasure.Expression<Treasure.AnyTreasureAction>?
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
@available(iOS 13.0, *)
public typealias CompositionalLayoutSectionProvider = (_ environment: UIKit.NSCollectionLayoutEnvironment) -> UIKit.NSCollectionLayoutSection
@available(iOS 13.0, *)
public protocol CompositionalLayoutSectionProviderProviding {
  var compositionalLayoutSectionProvider: Treasure.CompositionalLayoutSectionProvider? { get }
}
@available(iOS 13.0, *)
extension Treasure.SectionModel {
  public var compositionalLayoutSectionProvider: Treasure.CompositionalLayoutSectionProvider? {
    get
    set
  }
  public func compositionalLayoutSectionProvider(_ value: Treasure.CompositionalLayoutSectionProvider?) -> Treasure.SectionModel
  public func compositionalLayoutSection(_ section: UIKit.NSCollectionLayoutSection?) -> Treasure.SectionModel
}
public enum DynamicWidthNavigatorStyle {
  case equalWidth
  case widthByTitleLength
  public static func == (a: Treasure.DynamicWidthNavigatorStyle, b: Treasure.DynamicWidthNavigatorStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class DynamicWidthNavigatorView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var titles: [Swift.String]
  @_Concurrency.MainActor(unsafe) final public var internalBackgroundColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public static let height: CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) final public var userSelectedIndex: ((Swift.Int) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public init(titles: [Swift.String], internalBackgroundColor: UIKit.UIColor? = nil, style: Treasure.DynamicWidthNavigatorStyle = .equalWidth)
  @_Concurrency.MainActor(unsafe) final public func setupView(titles: [Swift.String], selectedIndex: Swift.Int, adjustScrollBar: Swift.Bool = false, containerWidth: CoreGraphics.CGFloat? = nil)
  @_Concurrency.MainActor(unsafe) final public func selectCategory(index: Swift.Int, adjustScrollBar: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) final public func animateScrollBarPosX(index: Swift.Int)
  @_Concurrency.MainActor(unsafe) final public func adjustScrollBarPosition(offsetX: CoreGraphics.CGFloat)
  @objc deinit
}
public protocol VerticalAlignmentProviding {
  var verticalAlignment: Treasure.HGroup.ItemAlignment? { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.VerticalAlignmentProviding {
  public var verticalAlignment: Treasure.HGroup.ItemAlignment? {
    get
    set
  }
  public func verticalAlignment(_ value: Treasure.HGroup.ItemAlignment?) -> Self
}
public protocol SafeAreaLayoutMarginsBarView : UIKit.UIView {
  var preferredSafeAreaLayoutMarginsBehavior: Treasure.SafeAreaLayoutMarginsBehavior { get }
}
public enum SafeAreaLayoutMarginsBehavior {
  case max
  case sum
  public static func == (a: Treasure.SafeAreaLayoutMarginsBehavior, b: Treasure.SafeAreaLayoutMarginsBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol APIClientProtocol {
  typealias CompletionHandler<T> = (Swift.Result<T, Swift.Error>) -> Swift.Void
  func perform<R>(_ request: R, completionHandler: @escaping Self.CompletionHandler<R.ResponseType>) where R : Treasure.TreasureAPIRequest
}
final public class APIClient : Treasure.APIClientProtocol {
  public init(environment: Treasure.APIEnvironment)
  final public func perform<R>(_ request: R, completionHandler: @escaping Treasure.APIClient.CompletionHandler<R.ResponseType>) where R : Treasure.TreasureAPIRequest
  @objc deinit
}
public struct CardContainerElementStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public let cardCornerRadius: Swift.Double?
  public let cardSpecificCornerRadius: Treasure.CornerRadius?
  public let cardLayoutMargins: Treasure.LayoutMargins?
  public let cardBackgroundColor: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public struct CardContainerElement : Treasure.TreasureElement {
  public let id: Swift.String
  public let item: Treasure.TreasureElement?
  public let backgroundBlurImage: Treasure.Expression<Treasure.TreasureImageSource>?
  public let style: Treasure.Expression<Swift.String>?
  public func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
public struct ItemPath : Swift.Hashable {
  public init(itemDataID: Swift.AnyHashable, section: Treasure.ItemPath.Section)
  public enum Section : Swift.Hashable {
    case dataID(Swift.AnyHashable)
    case lastWithItemDataID
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Treasure.ItemPath.Section, b: Treasure.ItemPath.Section) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public var itemDataID: Swift.AnyHashable
  public var section: Treasure.ItemPath.Section
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Treasure.ItemPath, b: Treasure.ItemPath) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public typealias OperationHandler = (_ parameters: [Treasure.DynamicObject]) -> Treasure.DynamicObject
public struct Operation {
  public let name: Swift.String
  public let parameters: [Treasure.Operation.Parameter]
  public enum Parameter : Swift.Equatable {
    case operation(Treasure.Operation)
    case value(Treasure.Value)
    public static func == (a: Treasure.Operation.Parameter, b: Treasure.Operation.Parameter) -> Swift.Bool
  }
  public init(name: Swift.String, parameters: [Treasure.Operation.Parameter] = [])
}
extension Treasure.Operation : Treasure.RepresentableByParsableString {
  public static let parser: Treasure.Parser<Treasure.Operation>
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public protocol DidDisplayProviding {
}
extension Treasure.CallbackContextEpoxyModeled where Self : Treasure.DidDisplayProviding {
  public typealias DidDisplay = ((_ context: Self.CallbackContext) -> Swift.Void)
  public var didDisplay: Self.DidDisplay? {
    get
    set
  }
  public func didDisplay(_ value: Self.DidDisplay?) -> Self
}
public struct AnyGroupItem : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public var storage: Treasure.EpoxyModelStorage {
    get
    set
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension Treasure.AnyGroupItem : Treasure.GroupItemModeling {
  public func eraseToAnyGroupItem() -> Treasure.AnyGroupItem
}
extension Treasure.AnyGroupItem {
  public var dataID: Swift.AnyHashable {
    get
  }
  public func makeConstrainable() -> Treasure.Constrainable
  public func update(_ constrainable: Treasure.Constrainable, animated: Swift.Bool)
  public func setBehaviors(on constrainable: Treasure.Constrainable)
}
extension Treasure.AnyGroupItem : Treasure.DataIDProviding {
}
extension Treasure.AnyGroupItem : Treasure.SetContentProviding {
}
extension Treasure.AnyGroupItem : Treasure.SetBehaviorsProviding {
}
extension Treasure.AnyGroupItem : Treasure.CallbackContextEpoxyModeled {
  public struct CallbackContext {
    public let constrainable: Treasure.Constrainable
    public init(constrainable: Treasure.Constrainable)
  }
}
public protocol MakeConstrainableProviding {
  typealias MakeConstrainable = () -> Treasure.Constrainable
  var makeConstrainable: Self.MakeConstrainable { get }
}
extension Treasure.EpoxyModeled where Self : Treasure.MakeConstrainableProviding {
  public var makeConstrainable: Self.MakeConstrainable {
    get
    set
  }
  public func makeConstrainable(_ value: @escaping Self.MakeConstrainable) -> Self
}
public protocol TreasureLayout : Swift.Decodable {
  func populate(using populator: Treasure.TreasureLayoutPopulator) -> Treasure.LayoutPopulatorResult
}
public enum TreasureLayoutType : Swift.String {
  case singleColumn
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AnyTreasureLayout : Swift.Decodable {
  case singleColumn(Treasure.SingleColumnLayout)
  case none
  public init(from decoder: Swift.Decoder) throws
  public var value: Treasure.TreasureLayout? {
    get
  }
}
public struct LayoutsPerFormFactor : Swift.Decodable {
  public let compact: Treasure.AnyTreasureLayout?
  public let wide: Treasure.AnyTreasureLayout?
  public init(from decoder: Swift.Decoder) throws
}
public struct SectionDetail : Swift.Decodable {
  public let sectionId: Swift.String
  public let topPadding: Swift.Int?
  public let bottomPadding: Swift.Int?
  public init(from decoder: Swift.Decoder) throws
}
public struct SingleSectionPlacement : Swift.Decodable {
  public let sectionDetail: Treasure.SectionDetail
  public init(from decoder: Swift.Decoder) throws
}
public struct MultipleSectionsPlacement : Swift.Decodable {
  public let sectionDetails: [Treasure.SectionDetail]
  public init(from decoder: Swift.Decoder) throws
}
public protocol Dependency : AnyObject {
}
public protocol EmptyDependency : Treasure.Dependency {
}
public struct CollectionViewVisibilityMetadata {
  public init(sections: [Treasure.CollectionViewVisibilityMetadata.Section], collectionView: Treasure.CollectionView)
  public let sections: [Treasure.CollectionViewVisibilityMetadata.Section]
  weak public var collectionView: Treasure.CollectionView? {
    get
  }
}
extension Treasure.CollectionViewVisibilityMetadata {
  public struct Section {
    public init(model: Treasure.SectionModel, items: [Treasure.CollectionViewVisibilityMetadata.Item], supplementaryItems: [Swift.String : [Treasure.CollectionViewVisibilityMetadata.SupplementaryItem]])
    public let model: Treasure.SectionModel
    public let items: [Treasure.CollectionViewVisibilityMetadata.Item]
    public let supplementaryItems: [Swift.String : [Treasure.CollectionViewVisibilityMetadata.SupplementaryItem]]
  }
}
extension Treasure.CollectionViewVisibilityMetadata {
  public struct Item {
    public init(model: Treasure.AnyItemModel, view: UIKit.UIView?)
    public let model: Treasure.AnyItemModel
    weak public var view: UIKit.UIView? {
      get
    }
  }
}
extension Treasure.CollectionViewVisibilityMetadata {
  public struct SupplementaryItem {
    public init(model: Treasure.AnySupplementaryItemModel, view: UIKit.UIView?)
    public let model: Treasure.AnySupplementaryItemModel
    weak public var view: UIKit.UIView? {
      get
    }
  }
}
public enum VGroupContentAlignment : Swift.String, Swift.Decodable {
  case leading
  case center
  case trailing
  case fill
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HGroupContentAlignment : Swift.String, Swift.Decodable {
  case top
  case center
  case bottom
  case fill
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct GroupElementStyle : Treasure.ElementStyle {
  public let id: Swift.String
  public let basicProps: Treasure.ElementStyleProps?
  public let hGroupAlignment: Treasure.HGroupContentAlignment?
  public let vGroupAlignment: Treasure.VGroupContentAlignment?
  public let spacing: Swift.Double?
  public init(from decoder: Swift.Decoder) throws
}
public enum TreasureElementRenderType {
  case item
  case groupItem
  case barItem
  public static func == (a: Treasure.TreasureElementRenderType, b: Treasure.TreasureElementRenderType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TreasureElementParameters {
  public var elementID: Swift.String?
  public let renderType: Treasure.TreasureElementRenderType
  public let builder: Treasure.TreasureUIElementBuilder
  public let blueprintData: Treasure.BlueprintElement?
  public func convertToIngredients<T>(element: T) -> Treasure.ElementBuilderIngredients<T> where T : Treasure.TreasureElement
}
public protocol TreasureElement : Swift.Decodable {
  var id: Swift.String { get }
  var style: Treasure.Expression<Swift.String>? { get }
  func buildUIElement(parameters: Treasure.TreasureElementParameters) -> Treasure.ElementRenderModeling?
}
public enum TreasureElementType : Swift.String {
  case label
  case image
  case button
  case basicListItem
  case vGroup
  case hGroup
  case divider
  case card
  case navBar
  case blueprint
  case contextElement
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AnyTreasureElement : Swift.Decodable {
  case label(Treasure.LabelElement)
  case image(Treasure.ImageElement)
  case button(Treasure.ButtonElement)
  case basicListItem(Treasure.BasicListItemElement)
  case vGroup(Treasure.VGroupElement)
  case hGroup(Treasure.HGroupElement)
  case divider(Treasure.DividerElement)
  case card(Treasure.CardContainerElement)
  case navBar(Treasure.NavBarElement)
  case blueprint(Treasure.BlueprintElement)
  case contextElement(Treasure.ContextElement)
  case none
  public init(from decoder: Swift.Decoder) throws
  public var value: Treasure.TreasureElement? {
    get
  }
}
public protocol TreasureElementDecoder {
  func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct UnsupportedElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct TitleElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct ImageElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct ButtonElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct BasicListItemElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct DividerElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct VGroupElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct HGroupElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct CardContainerElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct NavBarElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct BlueprintElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public struct ContextElementDecoder : Treasure.TreasureElementDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureElement
}
public enum AnyTreasureElementDecoder {
}
public struct ElementsSDKAction : Treasure.TreasureAction {
  public let analytics: Treasure.TreasureAnalytics?
  public let actionType: Swift.String
  public let data: Treasure.DynamicObject?
  public let onSuccess: [Treasure.AnyTreasureAction]?
  public let onError: [Treasure.AnyTreasureAction]?
  public let onFinish: [Treasure.AnyTreasureAction]?
  public init(from decoder: Swift.Decoder) throws
  public func executeAction(params: Treasure.TreasureActionParameters)
}
public typealias StringOrExpression = Swift.String
public enum Expression<T> where T : Swift.Decodable {
  case value(T)
  case expression(Treasure.ContextExpression)
}
public enum ContextExpression : Swift.Hashable {
  case single(Treasure.SingleExpression)
  case multiple(Treasure.MultipleExpression)
}
public enum SingleExpression : Swift.Hashable {
  case value(Treasure.Value)
  case operation(Treasure.Operation)
}
public struct MultipleExpression : Swift.Hashable {
  public let nodes: [Treasure.MultipleExpression.Node]
  public enum Node : Swift.Equatable {
    case string(Swift.String)
    case expression(Treasure.SingleExpression)
    public static func == (a: Treasure.MultipleExpression.Node, b: Treasure.MultipleExpression.Node) -> Swift.Bool
  }
  public init(nodes: [Treasure.MultipleExpression.Node])
}
extension Treasure.ContextExpression : Treasure.RepresentableByParsableString {
  public static var parser: Treasure.Parser<Treasure.ContextExpression>
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension Treasure.SingleExpression : Treasure.RepresentableByParsableString {
  public static let parser: Treasure.Parser<Treasure.SingleExpression>
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension Treasure.MultipleExpression : Treasure.RepresentableByParsableString {
  public static let parser: Treasure.Parser<Treasure.MultipleExpression>
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension Treasure.Expression : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Treasure.Expression : Swift.ExpressibleByStringInterpolation {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension Treasure.Expression : Swift.ExpressibleByIntegerLiteral where T == Swift.Int {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension Treasure.Expression : Swift.ExpressibleByFloatLiteral where T == Swift.Float {
  public init(floatLiteral value: Swift.Float)
  public typealias FloatLiteralType = Swift.Float
}
extension Treasure.Expression : Swift.ExpressibleByBooleanLiteral where T == Swift.Bool {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension Treasure.Expression : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: Treasure.Expression<T>, rhs: Treasure.Expression<T>) -> Swift.Bool
}
extension Treasure.Expression : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
public protocol Constrainable {
  var leadingAnchor: UIKit.NSLayoutXAxisAnchor { get }
  var trailingAnchor: UIKit.NSLayoutXAxisAnchor { get }
  var leftAnchor: UIKit.NSLayoutXAxisAnchor { get }
  var rightAnchor: UIKit.NSLayoutXAxisAnchor { get }
  var topAnchor: UIKit.NSLayoutYAxisAnchor { get }
  var bottomAnchor: UIKit.NSLayoutYAxisAnchor { get }
  var widthAnchor: UIKit.NSLayoutDimension { get }
  var heightAnchor: UIKit.NSLayoutDimension { get }
  var centerXAnchor: UIKit.NSLayoutXAxisAnchor { get }
  var centerYAnchor: UIKit.NSLayoutYAxisAnchor { get }
  var firstBaselineAnchor: UIKit.NSLayoutYAxisAnchor { get }
  var lastBaselineAnchor: UIKit.NSLayoutYAxisAnchor { get }
  var dataID: Swift.AnyHashable { get }
  var owningView: UIKit.UIView? { get }
  var layoutFrame: CoreGraphics.CGRect { get }
  func install(in view: UIKit.UIView)
  func uninstall()
  func isEqual(to constrainable: Treasure.Constrainable) -> Swift.Bool
}
extension Treasure.Constrainable where Self : ObjectiveC.NSObject {
  public var dataID: Swift.AnyHashable {
    get
  }
}
extension Treasure.Constrainable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
extension UIKit.UIView : Treasure.Constrainable {
  @_Concurrency.MainActor(unsafe) public var owningView: UIKit.UIView? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var layoutFrame: CoreGraphics.CGRect {
    get
  }
  @_Concurrency.MainActor(unsafe) public func install(in view: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) public func uninstall()
  @_Concurrency.MainActor(unsafe) public func isEqual(to constrainable: Treasure.Constrainable) -> Swift.Bool
}
extension Treasure.Constrainable {
  public func constrainToMargins(insets: UIKit.NSDirectionalEdgeInsets = .zero)
  public func constrainToMarginsWithHighPriorityBottom()
  public func constrainToSuperview()
}
@available(iOS 13.0, *)
extension UIKit.UICollectionViewCompositionalLayout {
  @_Concurrency.MainActor(unsafe) public static var epoxy: UIKit.UICollectionViewCompositionalLayout {
    get
  }
  @_Concurrency.MainActor(unsafe) public static func epoxy(configuration: UIKit.UICollectionViewCompositionalLayoutConfiguration) -> UIKit.UICollectionViewCompositionalLayout
}
public struct GeneralListContentSection : Treasure.TreasureSection {
  public struct Content : Swift.Decodable {
    public let items: [Treasure.AnyTreasureElement]
    public let title: Swift.String?
    public let subtitle: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
  public let id: Swift.String
  public let type: Swift.String
  public let section: Treasure.GeneralListContentSection.Content
  public let title: Swift.String?
  public let layout: Treasure.TreasureSectionLayoutData?
  public init(id: Swift.String, type: Swift.String, section: Treasure.GeneralListContentSection.Content, title: Swift.String? = nil, layout: Treasure.TreasureSectionLayoutData? = nil)
  public func buildUISection(parameters: Treasure.TreasureSectionParameters) -> Treasure.SectionRenderModeling?
  public init(from decoder: Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class TopBarContainer : Treasure.BarStackView {
  @objc required dynamic public init()
  public enum StatusBarInsetBehavior : Swift.Equatable {
    case visible
    case hidden(roomToReappear: Swift.Bool)
    public static func == (a: Treasure.TopBarContainer.StatusBarInsetBehavior, b: Treasure.TopBarContainer.StatusBarInsetBehavior) -> Swift.Bool
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var center: CoreGraphics.CGPoint {
    @_Concurrency.MainActor(unsafe) @objc get
    @_Concurrency.MainActor(unsafe) @objc set
  }
  @_Concurrency.MainActor(unsafe) final public var insetBehavior: Treasure.BarContainerInsetBehavior {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var insetMargins: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var statusBarInsetBehavior: Treasure.TopBarContainer.StatusBarInsetBehavior {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var isStatusBarHidden: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) weak final public var viewController: UIKit.UIViewController? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func didMoveToSuperview()
  @_Concurrency.MainActor(unsafe) final public func add(to superview: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) final public func remove()
  @objc deinit
}
public struct VGroupItem : Treasure.EpoxyModeled {
  public init(dataID: Swift.AnyHashable, style: Treasure.VGroup.Style = .init(), groupItems: Treasure.VGroupItem.Content)
  public init(dataID: Swift.AnyHashable, style: Treasure.VGroup.Style = .init(), @Treasure.GroupModelBuilder _ groupItemsBuilder: () -> Treasure.VGroupItem.Content)
  public typealias Content = [Treasure.GroupItemModeling]
  public var storage: Treasure.EpoxyModelStorage
  public var style: Treasure.VGroup.Style
}
extension Treasure.VGroupItem : Treasure.AccessibilityAlignmentProviding {
}
extension Treasure.VGroupItem : Treasure.DataIDProviding {
}
extension Treasure.VGroupItem : Treasure.HorizontalAlignmentProviding {
}
extension Treasure.VGroupItem : Treasure.PaddingProviding {
}
extension Treasure.VGroupItem : Treasure.VerticalAlignmentProviding {
}
extension Treasure.VGroupItem : Treasure.GroupItemsProviding {
}
extension Treasure.VGroupItem : Treasure.GroupItemModeling {
  public func eraseToAnyGroupItem() -> Treasure.AnyGroupItem
}
extension Treasure.VGroupItem {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func makeConstrainable() -> Treasure.Constrainable
  public func update(_ constrainable: Treasure.Constrainable, animated: Swift.Bool)
  public func setBehaviors(on constrainable: Treasure.Constrainable)
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
public protocol AnyRetryAPIClient : Treasure.APIClientProtocol {
  typealias ShouldRetryHandler<T> = (_ result: Swift.Result<T, Swift.Error>) -> Swift.Bool
  func perform<R>(_ request: R, shouldRetry: Self.ShouldRetryHandler<R.ResponseType>?, completionHandler: @escaping Self.CompletionHandler<R.ResponseType>) where R : Treasure.TreasureAPIRequest
}
final public class RetryAPIClient : Treasure.AnyRetryAPIClient {
  public init(apiClient: Treasure.APIClientProtocol, scheduler: Treasure.Scheduler)
  final public func perform<R>(_ request: R, completionHandler: @escaping Treasure.RetryAPIClient.CompletionHandler<R.ResponseType>) where R : Treasure.TreasureAPIRequest
  final public func perform<R>(_ request: R, shouldRetry: Treasure.RetryAPIClient.ShouldRetryHandler<R.ResponseType>?, completionHandler: @escaping Treasure.RetryAPIClient.CompletionHandler<R.ResponseType>) where R : Treasure.TreasureAPIRequest
  @objc deinit
}
public protocol TreasureImageLoadable : AnyObject {
  func setImage(imageView: UIKit.UIImageView, placeHolder: UIKit.UIImage?, url: Foundation.URL, completion: (() -> Swift.Void)?)
  func getImage(url: Foundation.URL, completion: ((UIKit.UIImage?) -> Swift.Void)?)
  func createAnimationView(url: Foundation.URL, imageMode: UIKit.UIView.ContentMode, completion: ((Swift.Error?) -> Swift.Void)?) -> UIKit.UIView
  func createAnimationView(animationName: Swift.String, imageMode: UIKit.UIView.ContentMode) -> UIKit.UIView
  func playAnimationImage(view: UIKit.UIView)
}
public struct SendRequestAction : Treasure.TreasureAction {
  public let url: Treasure.Expression<Swift.String>
  public let analytics: Treasure.TreasureAnalytics?
  public let method: Treasure.Expression<Treasure.HttpMethod>?
  public let data: Treasure.DynamicObject?
  public let headers: Treasure.Expression<[Swift.String : Swift.String]>?
  public let showLoading: Treasure.Expression<Swift.Bool>?
  public let onSuccess: [Treasure.AnyTreasureAction]?
  public let onError: [Treasure.AnyTreasureAction]?
  public let onFinish: [Treasure.AnyTreasureAction]?
  public init(from decoder: Swift.Decoder) throws
  public func executeAction(params: Treasure.TreasureActionParameters)
}
public protocol CollectionViewDisplayDelegate : AnyObject {
  func collectionView(_ collectionView: Treasure.CollectionView, willDisplayItem item: Treasure.AnyItemModel, with view: UIKit.UIView?, in section: Treasure.SectionModel)
  func collectionView(_ collectionView: Treasure.CollectionView, didEndDisplayingItem item: Treasure.AnyItemModel, with view: UIKit.UIView?, in section: Treasure.SectionModel)
  func collectionView(_ collectionView: Treasure.CollectionView, willDisplaySupplementaryItem item: Treasure.AnySupplementaryItemModel, forElementKind elementKind: Swift.String, with view: UIKit.UIView?, in section: Treasure.SectionModel)
  func collectionView(_ collectionView: Treasure.CollectionView, didEndDisplayingSupplementaryItem item: Treasure.AnySupplementaryItemModel, forElementKind elementKind: Swift.String, with view: UIKit.UIView?, in section: Treasure.SectionModel)
}
public struct SingleColumnLayout : Treasure.TreasureLayout {
  public let nav: Treasure.MultipleSectionsPlacement?
  public let main: Treasure.MultipleSectionsPlacement
  public let floatingFooter: Treasure.MultipleSectionsPlacement?
  public func populate(using populator: Treasure.TreasureLayoutPopulator) -> Treasure.LayoutPopulatorResult
  public init(from decoder: Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class VisualEffectView : UIKit.UIVisualEffectView {
  @_Concurrency.MainActor(unsafe) open var colorTint: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var colorTintAlpha: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var blurRadius: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var scale: CoreGraphics.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(effect: UIKit.UIVisualEffect?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class LoadingFullScreenHUD : Treasure.FullScreenPresentableView {
  @_Concurrency.MainActor(unsafe) final public let nvIndicatorContainerView: UIKit.UIView
  @_Concurrency.MainActor(unsafe) final public let nvIndicatorView: Treasure.NVActivityIndicatorView
  @_Concurrency.MainActor(unsafe) final public var minEndPresentingTime: Foundation.Date
  @_Concurrency.MainActor(unsafe) final public func show(minDisplayTime: Foundation.TimeInterval = 1)
  @_Concurrency.MainActor(unsafe) override final public func animateForOpening()
  @_Concurrency.MainActor(unsafe) override final public func hide(duration: Foundation.TimeInterval = 0.15, completion: (() -> Swift.Void)?)
  @_Concurrency.MainActor(unsafe) override final public func setupUI()
  @objc deinit
}
public protocol StyledView : UIKit.UIView {
  associatedtype Style : Swift.Hashable = Swift.Never
  init(style: Self.Style)
}
extension Treasure.StyledView where Self.Style == Swift.Never {
  public init(style: Swift.Never)
}
public struct CoordinatedBarModel {
  public init<Coordinator, Content, View>(dataID: Swift.AnyHashable? = nil, content: Content, viewType: View.Type, barModel: Coordinator.Model, makeCoordinator: @escaping (_ update: @escaping (_ animated: Swift.Bool) -> Swift.Void) -> Coordinator) where Coordinator : Treasure.BarCoordinating, Content : Swift.Equatable, View : UIKit.UIView
  public var storage: Treasure.EpoxyModelStorage
}
extension Treasure.CoordinatedBarModel : Treasure.DataIDProviding {
}
extension Treasure.CoordinatedBarModel : Treasure.StyleIDProviding {
}
extension Treasure.CoordinatedBarModel : Treasure.BarModeling {
  public func eraseToAnyBarModel() -> Treasure.AnyBarModel
}
extension Treasure.CoordinatedBarModel : Treasure.InternalBarCoordinating {
  public func makeCoordinator(update: @escaping (Swift.Bool) -> Swift.Void) -> Treasure.AnyBarCoordinating
  public func barModel(for coordinator: Treasure.AnyBarCoordinating) -> Treasure.BarModeling
  public func canReuseCoordinator(_ coordinator: Treasure.AnyBarCoordinating) -> Swift.Bool
}
extension Treasure.CoordinatedBarModel : Treasure.Diffable {
  public var diffIdentifier: Swift.AnyHashable {
    get
  }
  public func isDiffableItemEqual(to otherDiffableItem: Treasure.Diffable) -> Swift.Bool
}
public enum TreasureSectionType : Swift.String {
  case generalListContent
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol TreasureSectionDecoder {
  func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureSection
}
public struct UnsupportedSectionDecoder : Treasure.TreasureSectionDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureSection
}
public struct GeneralListContentSectionDecoder : Treasure.TreasureSectionDecoder {
  public func decode(from decoder: Swift.Decoder) throws -> Treasure.AnyTreasureSection
}
public enum AnyTreasureSectionDecoder {
}
public struct Path {
  public let nodes: [Treasure.Path.Node]
  public enum Node : Swift.Equatable {
    case key(Swift.String)
    case index(Swift.Int)
    public static func == (a: Treasure.Path.Node, b: Treasure.Path.Node) -> Swift.Bool
  }
  public init(nodes: [Treasure.Path.Node])
}
extension Treasure.Path : Treasure.RepresentableByParsableString {
  public static let parser: Treasure.Parser<Treasure.Path>
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension UIKit.UINavigationController {
  @_Concurrency.MainActor(unsafe) public func push(_ viewController: UIKit.UIViewController, animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func pop(animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
}
extension Treasure.SectionModel {
  public func getItemViewDifferentiators() -> Swift.Set<Treasure.ViewDifferentiator>
  public func getSupplementaryViewDifferentiators() -> [Swift.String : Swift.Set<Treasure.ViewDifferentiator>]
}
extension Swift.Array where Element == Treasure.SectionModel {
  public func getItemViewDifferentiators() -> Swift.Set<Treasure.ViewDifferentiator>
  public func getSupplementaryViewDifferentiators() -> [Swift.String : Swift.Set<Treasure.ViewDifferentiator>]
}
public typealias GroupModelBuilder = Treasure.EpoxyModelArrayBuilder<Treasure.GroupItemModeling>
extension Treasure.SwipeButtonDisplayMode : Swift.Equatable {}
extension Treasure.SwipeButtonDisplayMode : Swift.Hashable {}
extension Treasure.SwipeButtonStyle : Swift.Equatable {}
extension Treasure.SwipeButtonStyle : Swift.Hashable {}
extension Treasure.SwipeActionDescriptor : Swift.Equatable {}
extension Treasure.SwipeActionDescriptor : Swift.Hashable {}
extension Treasure.HGroup : Treasure.Group {}
extension Treasure.ImageContentMode : Swift.Equatable {}
extension Treasure.ImageContentMode : Swift.Hashable {}
extension Treasure.ImageContentMode : Swift.RawRepresentable {}
extension Treasure.ElementStyleType : Swift.Equatable {}
extension Treasure.ElementStyleType : Swift.Hashable {}
extension Treasure.ElementStyleType : Swift.RawRepresentable {}
extension Treasure.CollectionView.UpdateStrategy : Swift.Equatable {}
extension Treasure.CollectionView.UpdateStrategy : Swift.Hashable {}
extension Treasure.PresentationStyle : Swift.Equatable {}
extension Treasure.PresentationStyle : Swift.Hashable {}
extension Treasure.PresentationStyle : Swift.RawRepresentable {}
extension Treasure.ScreenModalType : Swift.Equatable {}
extension Treasure.ScreenModalType : Swift.Hashable {}
extension Treasure.ScreenModalType : Swift.RawRepresentable {}
extension Treasure.TreasureAnalyticsType : Swift.Equatable {}
extension Treasure.TreasureAnalyticsType : Swift.Hashable {}
extension Treasure.TreasureAnalyticsType : Swift.RawRepresentable {}
extension Treasure.AnySupplementaryItemModel : Treasure.ViewDifferentiatorProviding {}
extension Treasure.VGroup : Treasure.Group {}
extension Treasure.NVActivityIndicatorType : Swift.Equatable {}
extension Treasure.NVActivityIndicatorType : Swift.Hashable {}
extension Treasure.NVActivityIndicatorType : Swift.RawRepresentable {}
extension Treasure.LogLevel : Swift.Equatable {}
extension Treasure.LogLevel : Swift.Hashable {}
extension Treasure.Log.Expression : Swift.Equatable {}
extension Treasure.Log.Expression : Swift.Hashable {}
extension Treasure.SupplementaryItemModel : Treasure.ViewDifferentiatorProviding {}
extension Treasure.BottomBarContainer : Treasure.BarContainer {}
extension Treasure.BottomLineVisibility : Swift.Equatable {}
extension Treasure.BottomLineVisibility : Swift.Hashable {}
extension Treasure.BottomLineVisibility : Swift.RawRepresentable {}
extension Treasure.SystemThemeType : Swift.Equatable {}
extension Treasure.SystemThemeType : Swift.Hashable {}
extension Treasure.TextLabelAlignment : Swift.Equatable {}
extension Treasure.TextLabelAlignment : Swift.Hashable {}
extension Treasure.TextLabelAlignment : Swift.RawRepresentable {}
extension Treasure.HGroupContentAlignment : Swift.Equatable {}
extension Treasure.HGroupContentAlignment : Swift.Hashable {}
extension Treasure.HGroupContentAlignment : Swift.RawRepresentable {}
extension Treasure.VGroupContentAlignment : Swift.Equatable {}
extension Treasure.VGroupContentAlignment : Swift.Hashable {}
extension Treasure.VGroupContentAlignment : Swift.RawRepresentable {}
extension Treasure.TreasureLayoutOrthogonalScrollingType : Swift.Equatable {}
extension Treasure.TreasureLayoutOrthogonalScrollingType : Swift.Hashable {}
extension Treasure.TreasureLayoutOrthogonalScrollingType : Swift.RawRepresentable {}
extension Treasure.ItemCellState : Swift.Equatable {}
extension Treasure.ItemCellState : Swift.Hashable {}
extension Treasure.APIErrorType : Swift.Equatable {}
extension Treasure.APIErrorType : Swift.Hashable {}
extension Treasure.APIErrorType : Swift.RawRepresentable {}
extension Treasure.TreasureActionType : Swift.Equatable {}
extension Treasure.TreasureActionType : Swift.Hashable {}
extension Treasure.TreasureActionType : Swift.RawRepresentable {}
extension Treasure.NavigationStyle : Swift.Equatable {}
extension Treasure.NavigationStyle : Swift.Hashable {}
extension Treasure.HttpMethod : Swift.Equatable {}
extension Treasure.HttpMethod : Swift.Hashable {}
extension Treasure.HttpMethod : Swift.RawRepresentable {}
extension Treasure.CollectionSectionItemLayoutSizeType : Swift.Equatable {}
extension Treasure.CollectionSectionItemLayoutSizeType : Swift.Hashable {}
extension Treasure.CollectionSectionItemLayoutSizeType : Swift.RawRepresentable {}
extension Treasure.TreasureSectionLayoutType : Swift.Equatable {}
extension Treasure.TreasureSectionLayoutType : Swift.Hashable {}
extension Treasure.TreasureSectionLayoutType : Swift.RawRepresentable {}
extension Treasure.TreasureImageType : Swift.Equatable {}
extension Treasure.TreasureImageType : Swift.Hashable {}
extension Treasure.TreasureImageType : Swift.RawRepresentable {}
extension Treasure.BarStackView.ZOrder : Swift.Equatable {}
extension Treasure.BarStackView.ZOrder : Swift.Hashable {}
extension Treasure.StaticGroupItem : Treasure.EpoxyModeled {}
extension Treasure.StaticGroupItem : Treasure.GroupItemModeling {}
extension Treasure.TreasureSectionRenderType : Swift.Equatable {}
extension Treasure.TreasureSectionRenderType : Swift.Hashable {}
extension Treasure.BarContainerInsetBehavior : Swift.Hashable {}
extension Treasure.DynamicWidthNavigatorStyle : Swift.Equatable {}
extension Treasure.DynamicWidthNavigatorStyle : Swift.Hashable {}
extension Treasure.SafeAreaLayoutMarginsBehavior : Swift.Equatable {}
extension Treasure.SafeAreaLayoutMarginsBehavior : Swift.Hashable {}
extension Treasure.TreasureLayoutType : Swift.Equatable {}
extension Treasure.TreasureLayoutType : Swift.Hashable {}
extension Treasure.TreasureLayoutType : Swift.RawRepresentable {}
extension Treasure.TreasureElementRenderType : Swift.Equatable {}
extension Treasure.TreasureElementRenderType : Swift.Hashable {}
extension Treasure.TreasureElementType : Swift.Equatable {}
extension Treasure.TreasureElementType : Swift.Hashable {}
extension Treasure.TreasureElementType : Swift.RawRepresentable {}
extension Treasure.TopBarContainer : Treasure.BarContainer {}
extension Treasure.TreasureSectionType : Swift.Equatable {}
extension Treasure.TreasureSectionType : Swift.Hashable {}
extension Treasure.TreasureSectionType : Swift.RawRepresentable {}
